package soc.ourRobot;

import soc.client.SOCDisplaylessPlayerClient;
import soc.disableDebug.D;

import soc.robot.SOCBuildingSpeedEstimate;
import soc.robot.SOCRobotBrain;
import soc.robot.SOCRobotNegotiator;
import soc.robot.SOCRobotClient;
import soc.robot.SOCPossiblePiece;
import soc.robot.SOCPossibleRoad;

import soc.game.SOCBoard;
import soc.game.SOCCity;
import soc.game.SOCDevCardConstants;
import soc.game.SOCDevCardSet;
import soc.game.SOCGame;
import soc.game.SOCPlayer;
import soc.game.SOCPlayerNumbers;
import soc.game.SOCPlayingPiece;
import soc.game.SOCResourceConstants;
import soc.game.SOCResourceSet;
import soc.game.SOCRoad;
import soc.game.SOCSettlement;
import soc.game.SOCTradeOffer;

import soc.message.SOCAcceptOffer;
import soc.message.SOCCancelBuildRequest;
import soc.message.SOCChoosePlayerRequest;
import soc.message.SOCClearOffer;
import soc.message.SOCDevCard;
import soc.message.SOCDevCardCount;
import soc.message.SOCDiceResult;
import soc.message.SOCDiscardRequest;
import soc.message.SOCFirstPlayer;
import soc.message.SOCGameState;
import soc.message.SOCGameTextMsg;
import soc.message.SOCMakeOffer;
import soc.message.SOCMessage;
import soc.message.SOCMoveRobber;
import soc.message.SOCPlayerElement;
import soc.message.SOCPotentialSettlements;
import soc.message.SOCPutPiece;
import soc.message.SOCRejectOffer;
import soc.message.SOCResourceCount;
import soc.message.SOCSetPlayedDevCard;
import soc.message.SOCSetTurn;
import soc.message.SOCTurn;

import soc.server.SOCServer;

import soc.util.CappedQueue;
import soc.util.CutoffExceededException;
import soc.util.DebugRecorder;
import soc.util.Queue;
import soc.util.SOCRobotParameters;

import java.util.*;


public class SOCOurBrain extends SOCRobotBrain {
	
	/** Strategy we are playing in this game
	 * 
	 *  0 = Balanced, 1 = Roads/Settlements, 2 = Cities/Development Cards
	 */
	private int strategy;
	
	static final float[] FPROB = 
    {
        0.0f, 0.0f, 0.03f, 0.06f, 0.08f, 0.11f, 0.14f, 0.17f, 0.14f, 0.11f,
        0.08f, 0.06f, 0.03f
    };
	
	static final double[] PROB = 
    {
        0.0, 0.0, 0.03, 0.06, 0.08, 0.11, 0.14, 0.17, 0.14, 0.11,
        0.08, 0.06, 0.03
    };
	
	 private final int cityWeight= 5;
	 private final int settlementWeight= 3;
	 private final int roadWeight= 1;
	 private final int devCardWeight= 2; // should depend on strategy

	/**
     * Create a robot brain to play a game.
     *<P>
     * Depending on {@link SOCGame#getGameOptions() game options},
     * constructor might copy and alter the robot parameters
     * (for example, to clear {@link SOCRobotParameters#getTradeFlag()}).
     *
     * @param rc  the robot client
     * @param params  the robot parameters
     * @param ga  the game we're playing
     * @param mq  the message queue
     */
    public SOCOurBrain(SOCRobotClient rc, SOCRobotParameters params, SOCGame ga, CappedQueue mq)
    {
    	super(rc, params, ga, mq);
    }
 
 
	 /**
	  * Current Trading AI
	  * Accepts all offers
	  */
	 protected int considerOffer(SOCTradeOffer offer)
	 {
	     return SOCRobotNegotiator.ACCEPT_OFFER;
	 }
	 
	 /**
	     * figure out where to place the two settlements
	     */
	    
	    protected void planInitialSettlements()
	    {
	    	double bestScore = 0.0;
	    	double secondBestScore = 0.0;
	    	firstSettlement = -1;
	    	secondSettlement = -1;
	    	SOCBoard board = game.getBoard();
	    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
	        {
	            if (ourPlayerData.isPotentialSettlement(firstNode))
	            {
	            	double currentScore = 0.0;
	                Integer nodeInt = new Integer(firstNode);
	                Enumeration hexes = SOCBoard.getAdjacentHexesToNode(firstNode).elements();
	                
	                while (hexes.hasMoreElements())
	                {
	                    Integer hex = (Integer) hexes.nextElement();
	                    int number = board.getNumberOnHexFromCoord(hex.intValue());
	                    currentScore += PROB[number];
	                }
	                if(firstSettlement == -1 || currentScore > bestScore) {
	                	secondSettlement = firstSettlement;
	                	firstSettlement = nodeInt;
	                	secondBestScore = bestScore;
	                	bestScore = currentScore;
	                }
	                else if(secondSettlement == -1 || currentScore > secondBestScore) {
	                	secondSettlement = nodeInt;
	                	secondBestScore = currentScore;
	                }
	            }
	        }
	    }

	    /**
	     * figure out where to place the second settlement
	     */
	    protected void planSecondSettlement()
	    {
	    	//client.sendText(game,"placing our second settlement.");
	    	if(ourPlayerData.isPotentialSettlement(secondSettlement))
	    		return;
	    		
	    	double bestScore = 0.0;
	    	secondSettlement = -1;
	    	SOCBoard board = game.getBoard();
	    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
	        {
	            if (ourPlayerData.isPotentialSettlement(firstNode))
	            {
	            	double currentScore = 0.0;
	                Integer nodeInt = new Integer(firstNode);
	                Enumeration hexes = SOCBoard.getAdjacentHexesToNode(firstNode).elements();
	                
	                while (hexes.hasMoreElements())
	                {
	                    Integer hex = (Integer) hexes.nextElement();
	                    int number = board.getNumberOnHexFromCoord(hex.intValue());
	                    currentScore += PROB[number];
	                }
	                if(secondSettlement == -1 || currentScore > bestScore) {
	                	secondSettlement = nodeInt;
	                	bestScore = currentScore;
	                }
	            }
	        }
	    }

	    /**
	     * place planned first settlement
	     */
	    protected void placeFirstSettlement()
	    {
	        //D.ebugPrintln("BUILD REQUEST FOR SETTLEMENT AT "+Integer.toHexString(firstSettlement));
	        pause(500);
	        lastStartingPieceCoord = firstSettlement;
	        client.putPiece(game, new SOCSettlement(ourPlayerData, firstSettlement, null));
	        pause(1000);
	    }

	    /**
	     * place planned second settlement
	     */
	    protected void placeSecondSettlement()
	    {
	        if (secondSettlement == -1)
	        {
	            // This could mean that the server (incorrectly) asked us to
	            // place another second settlement, after we've cleared the
	            // potentialSettlements contents.
	            System.err.println("robot assert failed: secondSettlement -1, " + ourPlayerData.getName() + " leaving game " + game.getName());
	            failedBuildingAttempts = 2 + (2 * MAX_DENIED_BUILDING_PER_TURN);
	            waitingForGameState = false;
	            return;
	        }

	        //D.ebugPrintln("BUILD REQUEST FOR SETTLEMENT AT "+Integer.toHexString(secondSettlement));
	        pause(500);
	        lastStartingPieceCoord = secondSettlement;
	        client.putPiece(game, new SOCSettlement(ourPlayerData, secondSettlement, null));
	        pause(1000);
	    }

	    /**
	     * Plan and place a road attached to our most recently placed initial settlement,
	     * in game states {@link SOCGame#START1B START1B}, {@link SOCGame#START2B START2B}.
	     *<P>
	     * Road choice is based on the best nearby potential settlements, and doesn't
	     * directly check {@link SOCPlayer#isPotentialRoad(int) ourPlayerData.isPotentialRoad(edgeCoord)}.
	     * If the server rejects our road choice, then {@link #cancelWrongPiecePlacementLocal(SOCPlayingPiece)}
	     * will need to know which settlement node we were aiming for,
	     * and call {@link SOCPlayer#clearPotentialSettlement(int) ourPlayerData.clearPotentialSettlement(nodeCoord)}.
	     * The {@link #lastStartingRoadTowardsNode} field holds this coordinate.
	     */
	    public void placeInitRoad()
	    {
	    	//client.sendText(game,"Placing our road.");
	        final int settlementNode = ourPlayerData.getLastSettlementCoord();

	        int[] choices = game.getBoard().getAdjacentEdgesToNode_arr(settlementNode);
	    	
	    	//randomly pick road direction
	        int rand = (int)(Math.random()*(3));
	        
	        //Pick based on possible future progress
			int bestSpot = choices[0];
			float bestVal = -1;
			float curVal = -1;
	    	for (int i=0;i < 3;i++) {
	    		if(choices[i] != -1) {
	    			Vector<Integer> nextRoads = game.getBoard().getAdjacentEdgesToEdge(choices[i]);
	    			for (int j=0;j<nextRoads.size();j++) {
	        			if(nextRoads.get(j) != -1) {
	        				Vector<Integer> nextNodes = game.getBoard().getAdjacentNodesToEdge(nextRoads.get(j));
	        				for (int k=0;k<nextNodes.size();k++) {
	        					if (ourPlayerData.isPotentialSettlement(nextNodes.get(k))) {
	        						Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(nextNodes.get(k));
	        						curVal = 0;
	        						for(int l=0;l<adjHexes.size();l++) {
	        							curVal = curVal + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(l))];
	        						}
	        						if (curVal > bestVal) {
	        							bestVal = curVal;
	        							bestSpot = choices[i];
	        						}
	        					}
	        				}
	        			}
	        		}
	    		}
	    	}
	    	
	    	//random
	    	int roadEdge = choices[rand];
	    	//"best"
	    	// int roadEdge = bestSpot;
	    	
	    	int[] endPoints = game.getBoard().getAdjacentNodesToEdge_arr(roadEdge);
	    	int destination = endPoints[0];
	    	if(destination == settlementNode)
	    		destination = endPoints[1];
	    	
	        //D.ebugPrintln("!!! PUTTING INIT ROAD !!!");
	        pause(500);

	        //D.ebugPrintln("Trying to build a road at "+Integer.toHexString(roadEdge));
	        lastStartingPieceCoord = roadEdge;
	        lastStartingRoadTowardsNode = destination;
	        client.putPiece(game, new SOCRoad(ourPlayerData, roadEdge, null));
	        pause(1000);
	    }
	
    
    
    /** Returns a ranking of the given resource set based on how much can be built
     * using it. Does not consider bank trades.
     * Different constructs are given different weights, using tunable parameters.
     *  
     * @param set SOCResourceSet to rank
     * @return ranking of this set
     */
    private int rankResourceSet(SOCResourceSet set){
    	//int city, settl, rd, card;
    	//max(cityWeight*city+settlementWeight*settl+roadWeight*rd+devCardWeight*dev);
    	//s.t. resource constraints
    	
    	int rank=0;
    	while(SOCResourceSet.gte(set,SOCGame.CITY_SET)){
    		set.subtract(SOCGame.CITY_SET);
    		rank+=cityWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.SETTLEMENT_SET)){
    		set.subtract(SOCGame.SETTLEMENT_SET);
    		rank+=settlementWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.CARD_SET)){
    		set.subtract(SOCGame.CARD_SET);
    		rank+=devCardWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.ROAD_SET)){
    		set.subtract(SOCGame.ROAD_SET);
    		rank+=roadWeight;
    	}
    	
    	return rank;
    }
    
    
    
    
    /** Decide whether or not to accept a given trade offer
     *  Will accept an offer if something additional can be built
     * @param offer the SOCTradeOffer offered to the robot
     * @return true if the trade should be accepted
     */
    
    protected boolean considerOffer2(SOCTradeOffer offer){
    	// int opp= offer.getFrom(); // opponent offering the trade
    	SOCResourceSet offered= offer.getGiveSet();
    	SOCResourceSet exchange= offer.getGiveSet();
    	SOCResourceSet current= ourPlayerData.getResources();
    	// return false if we cannot make the trade
    	if(!SOCResourceSet.gte(current,exchange)) return false;
    	// oldRank
    	int prevRank= rankResourceSet(current);
    	SOCResourceSet updated= current.copy();
    	updated.subtract(exchange);
    	updated.add(offered);
    	// current holds the new amount of resources
    	int newRank= rankResourceSet(updated);  	 
    	return newRank>prevRank;
    }
        
    
    protected void getDiscoveryResources(){
    	//SOCResourceSet current= player.getResources();
    	resourceChoices= new SOCResourceSet(2,0,0,0,0,0); // always request 2 clay for now
    }
    
    
    /**
     * Choose which resource we want to monopolize
     */
    protected void getMonopolyResources(){
    	monopolyChoice= SOCResourceConstants.ORE; // for now just pick ore
    }
    
    /** Decide whether or not to play a dev card during a turn
     * @param none
     * @return 
     */
    protected void playDevCards(){
    	//SOCDevCardSet
    	SOCDevCardSet cards = ourPlayerData.getDevCards();
    	if(cards.getNumUnplayed()==0) return;
    	int vptot= ourPlayerData.getTotalVP();
    	// Play victory point cards if we can win
    	if(vptot==10){
    		//TODO fix this
    		// play all vp cards
    		for(int i=SOCDevCardConstants.CAP;i<SOCDevCardConstants.TOW;i++){
    			if(cards.getAmount(SOCDevCardSet.OLD,i)>0){
    				client.playDevCard(game, i);
    	    	}
    		}
    		return;
    	}
    	// Play Knight card if we are threatened by robber
    	if(robberThreatening() && cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.KNIGHT)>0){
    		client.playDevCard(game, SOCDevCardConstants.KNIGHT);
    		return;
    	}
    	// Play Roads card if we have one
    	if(cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.ROADS)>0){
    		client.playDevCard(game, SOCDevCardConstants.ROADS);
    		return;
    	}
    	// Play discovery card if we have one
    	if(cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.DISC)>0){
    		getDiscoveryResources();
    		client.playDevCard(game, SOCDevCardConstants.DISC);
    		return;
    	}
    	if(cards.getAmount(SOCDevCardSet.OLD, SOCDevCardConstants.MONO)>0){
    		getMonopolyResources();
    		client.playDevCard(game, SOCDevCardConstants.MONO);
    		return;
    	}
    	
   }
    
    /** Indicates whether player is currently threatened by robber
     * 
     * @return true if robber adjacent to one of our settlements/cities, false otherwise
     */
    private boolean robberThreatening(){
    	SOCBoard board= game.getBoard();
    	int robHex= board.getRobberHex();
    	Vector threatened= game.getPlayersOnHex(robHex);
    	return threatened.contains(ourPlayerData.getPlayerNumber());
    }
    
    // Added by Ryan
    // Discards numDiscards resources at random
    // TODO Placeholder for real discard method
    protected void discard(int numDiscards) {
    	SOCResourceSet discards = new SOCResourceSet();
    	SOCGame.discardPickRandom(ourPlayerData.getResources(), numDiscards, discards, rand);
        client.discard(game, discards);
    }
    
    // Added by Ryan
    // Tries to build roads. Lots of roads.
    // TODO Placeholder for real planBuilding()
    protected void planBuilding()
    {
    	//this.client.sendText(this.game, "Robot is planning building.");
        for(int i=0; i<=game.getBoard().MAXEDGE; i++) {
        	if(ourPlayerData.isPotentialRoad(i))
        		buildingPlan.push(new SOCPossibleRoad(ourPlayerData, i, null));
        }
        		
    }
    
    
    protected void tradeWithBank(){
    	Vector settlements= ourPlayerData.getSettlements();
    	Vector cities= ourPlayerData.getCities();
    	boolean havePort= false;
    	for(int i=0; i<settlements.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i=0; i<cities.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i= 0; i<=SOCResourceConstants.WOOD; i++){
    		int numRes= ourPlayerData.getResources().getAmount(i);
    		SOCResourceSet give= new SOCResourceSet();
    		SOCResourceSet get= new SOCResourceSet();
    		get.add(1,(i+1)%SOCResourceConstants.WOOD);
    		if(numRes>=3 && havePort){
    			give.add(3,i);
    			client.bankTrade(game,give,get);   			
    		} else if(numRes>=4){
    			give.add(4,i);
    			client.bankTrade(game,give, get);
    		}
    		
    	}
    	
    }
    
    // Added by Ryan
    // Tries to build a road, doesn't bother trading
    // TODO Placeholder for buildOrGetResourceByTradeOrCard
    protected void buildOrGetResourceByTradeOrCard() {
    	printResources();
   	
    	tradeWithBank();
    	
    	SOCPossiblePiece targetPiece = (SOCPossiblePiece) buildingPlan.pop();
    	//client.sendText(game,targetPiece.toFriendlyString()); 
    	pause(2000);
    	if(SOCResourceSet.gte(ourPlayerData.getResources(),SOCGame.ROAD_SET)){
    		 whatWeWantToBuild= new SOCRoad(ourPlayerData, targetPiece.getCoordinates(), null);
    		 waitingForGameState = true;
             counter = 0;
             expectPLACING_ROAD = true;
             client.buildRequest(game, targetPiece.getType());
    	 }
    }
    
    /** Moves the robber when a seven is rolled (Nick)
     * 
     */
    protected void moveRobber() {
    	//Discard if more than 7 cards
    	//If using knights calls this function move the discarding elsewhere
    	// TODO Ryan: I think that this is called separately from moveRobber() by run()
    	/*
    	if(ourPlayerData.getNeedToDiscard()) {
    		SOCResourceSet selected = new SOCResourceSet();
    		int numToSelect = (int) Math.floor(ourPlayerData.getResources().getTotal()/2);
        	Random numGenerator = new Random();
        	SOCGame.discardPickRandom(ourPlayerData.getResources(),numToSelect,selected,numGenerator);
        	client.discard(game,selected);
    	}
    	*/
    	
    	//Find the best hex to place the robber
    	int current = game.getBoard().getRobberHex();
		int [] board = game.getBoard().getHexLandCoords();
		int bestSpot = current;
		float bestVal = -1;
		float curVal = -1;
		for(int i=0;i<board.length;i++) {
			//Don't rank hex if ours or current robber hex
			if(ourPlayerData.getNumbers().getNumberResourcePairsForHex(board[i]).isEmpty() && board[i] != current) {
				curVal = FPROB[(game.getBoard().getNumberOnHexFromNumber(board[i]))]*rankHexValue(board[i]);
				//If value is higher, this becomes our best spot
				if (curVal > bestVal) {
					bestVal = curVal;
					bestSpot = board[i];
				}
			}
		}
		client.moveRobber(game, ourPlayerData, bestSpot);
		
		//Choose player to steal from
		// TODO Ryan: moved to chooseRobberVictim(boolean[]), below
		//client.choosePlayer(game, playerToStealFrom(bestSpot));
	}
    
    /**
     * Chooses victim with most confirmed VPs, or most resources if VPs are equal
     */
    protected void chooseRobberVictim(boolean[] choices) {
    	int choice = -1;
    	/* Loop to choose at random, instead of for loop
        while (!choices[choice]) {
        	choice = Math.abs(rand.nextInt() % SOCGame.MAXPLAYERS);
        }
    	 */
    	for (int i = 0; i < game.maxPlayers; i++)
        {
            if (! game.isSeatVacant (i))
            {
                if (choices[i])
                {
                    if (choice == -1)
                    {
                        choice = i;
                    }
                    else
                    {
                        SOCPlayer current = game.getPlayer(i);
                        SOCPlayer best = game.getPlayer(choice);
                        
                    	if (current.getPublicVP() > best.getPublicVP()) {
                			choice = i;
                		} else if (current.getPublicVP() == best.getPublicVP()) {
                			if (current.getResources().getTotal() > best.getResources().getTotal()) {
                				choice = i;
                			}
                		}
                    }
                }
            }
        }
    	
    	client.choosePlayer(game, choice);
    }
    
    /** Returns the value given of a hex based on what is built there (Nick)
     * Rank: 	1 point for settlements
     * 			2 points for cities
     * 
     * @param hex coordinates of the hex to find the value of
     * @return value of the hex
     */
    private int rankHexValue(int hex) {
    	int val = 0;
    	for(int i=0;i<6;i++) {
    		SOCPlayingPiece piece = game.getBoard().settlementAtNode(game.getBoard().getAdjacentNodeToHex(hex,i));
    		if (piece instanceof SOCCity) {
    			val = val+2;
    		} else if (piece instanceof SOCSettlement) {
    			val = val+1;
    		}
    	}
    	return val;
    }
    
    /** Returns the player ID of the player to steal from (Nick)
     * 
     * @param hex coordinates of the hex to find the value of
     * @return player ID
     */
    // TODO Ryan: added the AI in this method to chooseRobberVictim(boolean[] choices) above
    private int playerToStealFrom(int hex) {
    	//Possible players
    	ArrayList<SOCPlayer> possible = new ArrayList<SOCPlayer>();
    	for(int i=0;i<6;i++) {
    		SOCPlayingPiece piece = game.getBoard().settlementAtNode(game.getBoard().getAdjacentNodeToHex(hex,i));
    		if (piece != null && !possible.contains(piece.getPlayer())) {
    			possible.add(piece.getPlayer());
    		}
    	}
    	//Select the best player
    	SOCPlayer best = possible.get(0);
    	SOCPlayer current;
    	for (int i=1;i<3;i++) {
    		current = possible.get(i);
    		if (current.getPublicVP() > best.getPublicVP()) {
    			best = current;
    		} else if (current.getPublicVP() == best.getPublicVP()) {
    			if (current.getResources().getTotal() > best.getResources().getTotal()) {
    				best = current;
    			}
    		}
    	}
    	return best.getPlayerNumber();
    }
    
    /** Returns the possible settlements a player can build (Nick)
     * 
     * @return Hash-table with probabilities as keys for node coordinates
     */
    protected Hashtable<Float,Integer> possibleSettlementSpots() {
    	Hashtable<Float,Integer> nodeProbPairs = new Hashtable<Float,Integer>();
		
    	//Go through each node on the board adding those that are legal
    	for (int i=SOCBoard.MINNODE; i<SOCBoard.MAXNODE;i++) {
			if(ourPlayerData.isPotentialSettlement(i)) {
				Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(i);
				Float current = 0f;
				for(int j=0;j<adjHexes.size();j++) {
					current = current + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(i))];
				}
				// Add rarity index here (current version prevents hash collision)
				if (!nodeProbPairs.containsValue(current)) {
					nodeProbPairs.put(current,i);
				} else {
					nodeProbPairs.put(current + 0.0001f, i);
				}
			}
    	}
    	return nodeProbPairs;
    }
    
    /** Chooses the first settlement during the initial set-up phase (Nick)
     * 
     */
    protected void pickFirstSettlement() {
    	strategy = 0;
    	
    	//Obtain possible settlements
    	/*
    	Hashtable<Float,Integer> possible = possibleSettlementSpots();
    	Float[] probs = possible.keySet().toArray(new Float[1]);
    	Arrays.sort(probs);	    	
    	
    	//Choose best option
    	client.putPiece(game, new SOCSettlement(ourPlayerData,possible.get(probs[0]),null));
    	*/
    	
    	// Just testing this out...
    	
    	//identify settlement
    	double bestScore = 0.0;
    	firstSettlement = -1;
    	SOCBoard board = game.getBoard();
    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
        {
            if (ourPlayerData.isPotentialSettlement(firstNode))
            {
            	double currentScore = 0.0;
                Integer firstNodeInt = new Integer(firstNode);
                Vector<Integer> hexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(firstNode).elements();
                for(Integer i: hexes) {
                	currentScore += PROB[i];
                }
                if(firstSettlement == -1 || currentScore < bestScore) {
                	firstSettlement = firstNodeInt;
                }
            }
        }
    	
    	//place it
    	gameStrategy(firstSettlement,null);
    	pause(500);
        lastStartingPieceCoord = firstSettlement;
        client.putPiece(game, new SOCSettlement(ourPlayerData, firstSettlement, null));
        pause(1000);
    }
    
    /** Chooses the second settlement during the initial set-up phase (Nick)
     * 
     */
    protected void pickSecondSettlement() {
    	//Obtain possible settlements
    	/*
    	Hashtable<Float,Integer> possible = possibleSettlementSpots();
    	Float[] probs = possible.keySet().toArray(new Float[1]);
    	Arrays.sort(probs);	    	
    	
    	//Choose best option
    	client.putPiece(game, new SOCSettlement(ourPlayerData,possible.get(probs[0]),null));
    	*/
    	
// Just testing this out...
    	
    	//identify settlement
    	double bestScore = 0.0;
    	secondSettlement = -1;
    	SOCBoard board = game.getBoard();
    	for (int secondNode = board.getMinNode(); secondNode <= SOCBoard.MAXNODE; secondNode++)
        {
            if (ourPlayerData.isPotentialSettlement(secondNode))
            {
            	double currentScore = 0.0;
                Integer secondNodeInt = new Integer(secondNode);
                Vector<Integer> hexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(secondNode).elements();
                for(Integer i: hexes) {
                	currentScore += PROB[i];
                }
                if(secondSettlement == -1 || currentScore < bestScore) {
                	secondSettlement = secondNodeInt;
                }
            }
        }
    	
    	//place it
    	gameStrategy(firstSettlement,secondSettlement);
    	pause(500);
        lastStartingPieceCoord = secondSettlement;
        client.putPiece(game, new SOCSettlement(ourPlayerData, secondSettlement, null));
        pause(1000);
    }
    
    /** Chooses where to build roads during the initial set-up phase (Nick)
     * 
     * @param node coordinate where the road must start from
     */
    protected void pickInitialRoad(int node) {
    	int[] choices = game.getBoard().getAdjacentEdgesToNode_arr(node);
    	
    	//randomly pick road direction
        int rand = (int)(Math.random()*(3));
        
        //Pick based on possible future progress
		int bestSpot = choices[0];
		float bestVal = -1;
		float curVal = -1;
    	for (int i=0;i < 3;i++) {
    		if(choices[i] != -1) {
    			Vector<Integer> nextRoads = game.getBoard().getAdjacentEdgesToEdge(choices[i]);
    			for (int j=0;j<nextRoads.size();j++) {
        			if(nextRoads.get(j) != -1) {
        				Vector<Integer> nextNodes = game.getBoard().getAdjacentNodesToEdge(nextRoads.get(j));
        				for (int k=0;k<nextNodes.size();k++) {
        					if (ourPlayerData.isPotentialSettlement(nextNodes.get(k))) {
        						Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(nextNodes.get(k));
        						curVal = 0;
        						for(int l=0;l<adjHexes.size();l++) {
        							curVal = curVal + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(l))];
        						}
        						if (curVal > bestVal) {
        							bestVal = curVal;
        							bestSpot = choices[i];
        						}
        					}
        				}
        			}
        		}
    		}
    	}
    	
    	client.putPiece(game, new SOCRoad(ourPlayerData,choices[rand],null));
    	//client.putPiece(game, new SOCRoad(player,bestSpot,null));
    }
 
    /** Returns the rarity index (probability distribution) for resources on the board (Nick)
     * 
     * @return Vector of float probabilities with indexes(in order): Other, Clay, Ore, Sheep, Wheat, Wood
     */
    private Vector<Float> rarityIndex() {
		Vector<Float> index = new Vector<Float>();
		for(int i=0;i<6;i++) {
			index.add(i, 0f);
		}
		int [] board = game.getBoard().getHexLandCoords();
		for(int i=0;i<board.length;i++) {
			float curProb = FPROB[game.getBoard().getNumberOnHexFromNumber(board[i])];
			switch (game.getBoard().getHexTypeFromCoord(board[i])) {
				case SOCResourceConstants.CLAY:
					index.set(SOCResourceConstants.CLAY, index.get(SOCResourceConstants.CLAY)+curProb);
					break;
				case SOCResourceConstants.ORE:
					index.set(SOCResourceConstants.ORE, index.get(SOCResourceConstants.ORE)+curProb);
					break;
				case SOCResourceConstants.SHEEP:
					index.set(SOCResourceConstants.SHEEP, index.get(SOCResourceConstants.SHEEP)+curProb);
					break;	
				case SOCResourceConstants.WHEAT:
					index.set(SOCResourceConstants.WHEAT, index.get(SOCResourceConstants.WHEAT)+curProb);
					break;
				case SOCResourceConstants.WOOD:
					index.set(SOCResourceConstants.WOOD, index.get(SOCResourceConstants.WOOD)+curProb);
					break;
				default:
					//Add all other hexes to first index for debugging purposes
					index.set(0, index.get(0)+curProb);
			}
		}
		return index;
    }
    
    /** Sets the game strategy for our agent using a combination of rarity index and settlements available
     * 
     * @param firstSettlement node coordinates of first settlement location
     * @param secondSettlement node coordinates of second settlement location (null if only first chosen)
     */
    private void gameStrategy(int firstSettlement, Integer secondSettlement) {
    	Vector<Float> rarity = rarityIndex();
    	Vector<Integer> firstHexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(firstSettlement);
    	Integer temp = firstHexes.get(0);
    	if (PROB[game.getBoard().getNumberOnHexFromCoord(firstHexes.get(0))] > FPROB[game.getBoard().getNumberOnHexFromCoord(firstHexes.get(1))]) {
    		temp = firstHexes.get(1);
    	} else {
    		temp = firstHexes.get(2);
    	}
    	switch (game.getBoard().getHexTypeFromCoord(temp)) {
		case SOCResourceConstants.CLAY:
			strategy = 1;
			break;
		case SOCResourceConstants.ORE:
			strategy = 2;
			break;
		case SOCResourceConstants.SHEEP:
			strategy = 0;
			break;	
		case SOCResourceConstants.WHEAT:
			strategy = 2;
			break;
		case SOCResourceConstants.WOOD:
			strategy = 1;
			break;
		default:
			//Add all other hexes to first index for debugging purposes
			strategy = 0;
	}
    	/*
    	if(secondSettlement != null) {
    		Vector<Integer> secondHexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(secondSettlement);
    	}*/
    	
    }
    
    /** Prints out list of resources for debugging purposes */
    private void printResources(){
    	client.sendText(game, ourPlayerData.getName()+" "+ourPlayerData.getResources().toFriendlyString());
    }
    

    
    /** Added by Katie
     * 
     * @return expected number of each type of resource per roll
     */
    protected double[] expectedNumResources(){
    	double[] resources= new double[6];
    	Vector settlements= getSettlements();
    	for (int i=0; i<=settlements.size(); i++){
    		int coord= ((SOCSettlement) settlements.get(i)).getCoordinates();
    		int type= game.getBoard().getHexTypeFromCoord(coord);
    		int number= game.getBoard().getNumberOnHexFromNumber(coord);
    		resources[type-1]+= PROB[number];
    	}
    	Vector cities= getCities();
    	for (int i=0; i< cities.size(); i++){
    		int coord= ((SOCCity) cities.get(i)).getCoordinates();
    		int type= game.getBoard().getHexTypeFromCoord(coord);
    		int number= game.getBoard().getNumberOnHexFromNumber(coord);
    		resources[type-1]+= 2*PROB[number];
    	}
    	return resources;
    }
    
    
    
    protected void tradeWithBank(){
    	Vector settlements= ourPlayerData.getSettlements();
    	Vector cities= ourPlayerData.getCities();
    	boolean havePort= false;
    	for(int i=0; i<settlements.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i=0; i<cities.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i= 0; i<=SOCResourceConstants.WOOD; i++){
    		int numRes= ourPlayerData.getResources().getAmount(i);
    		SOCResourceSet give= new SOCResourceSet();
    		SOCResourceSet get= new SOCResourceSet();
    		get.add(1,(i+1)%SOCResourceConstants.WOOD);
    		if(numRes>=3 && havePort){
    			give.add(3,i);
    			client.bankTrade(game,give,get);   			
    		} else if(numRes>=4){
    			give.add(4,i);
    			client.bankTrade(game,give, get);
    		}
    		
    	}
    	
    }
    
    
    /** Added by Katie 
     * A Move is a list of actions to perform in a turn, including
     * optionally a devCard to play, a series of bankTrades to make
     * and a series of pieces (including devCards to buy)*/
    
    private class Move {
    	private Vector<SOCTradeOffer> trades; // trades to make with the bank
    	private Vector<SOCPlayingPiece> pieces; // pieces to buy
    	private int buyDevCards; // the number of devCards to buy
    	private int devCard; // type of devCard to play, -1 if no devCard to play
    	
    	public Move(){
    		trades= new Vector<SOCTradeOffer>();
    		pieces= new Vector<SOCPlayingPiece>();
    		buyDevCards= 0;
    		devCard= -1; 
    	}
    	
    	public void addTrade(SOCTradeOffer t){
    		trades.add(t);
    	}
    	
    	public void addPiece(SOCPlayingPiece p){
    		pieces.add(p);
    	}
    	
    	public void setDevCards(int i){
    		buyDevCards=i;
    	}
    	
    	public Vector<SOCTradeOffer> getTrades(){
    		return trades;
    	}
    	
    	public Vector<SOCPlayingPiece> getPieces(){
    		return pieces;
    	}
    	public int devCardsToBuy(){
    		return buyDevCards;
    	}
    	public int devCardToPlay(){
    		return devCard;
    	}
    }
    
    // SOCGame.ROAD_SET
    
    /** Added by Katie- returns a Vector of all possible moves in a given turn
     * a move consists of a set of trades, a set of SOCpieces to build, and a
     * devCard to play
     * @return 
     */
    
    //TODO: Note*** Always trade first, then build cities, then the rest

    protected Vector<Move> possibleMoves(SOCGame game, int player){
    	SOCPlayer PlayerData= game.getPlayer(player);
    	Vector<Move> moves= new Vector<Move>();
    	
    	SOCResourceSet resources= PlayerData.getResources().copy();
    	
    	boolean[] potentialSettlements= PlayerData.getPotentialSettlements();
    	boolean[] potentialRoads= PlayerData.getPotentialRoads();
    	boolean[] potentialCities= PlayerData.getPotentialCities();
    	
    	int remainingSettlements= PlayerData.getNumPieces(SOCPlayingPiece.SETTLEMENT);
    	
    	int maxRoads=0;
    	while(SOCResourceSet.gte(resources,SOCGame.ROAD_SET)){
    		resources.subtract(SOCGame.ROAD_SET);
    		maxRoads++;
    	}
    	// min of roads available and resource limitations
    	maxRoads= Math.min(maxRoads,PlayerData.getNumPieces(SOCPlayingPiece.ROAD));
    	
    	// reset resources to initial values
    	resources= PlayerData.getResources().copy();
    	int maxSettlements=0;
    	while(SOCResourceSet.gte(resources,SOCGame.SETTLEMENT_SET)){
    		resources.subtract(SOCGame.SETTLEMENT_SET);
    		maxSettlements++;
    	} // can build a city in which case we have a settlement free
    	//maxSettlements= Math.min(maxSettlements, PlayerData.getNumPieces(SOCPlayingPiece.SETTLEMENT));
    	resources= PlayerData.getResources().copy();
    	int maxCities=0;
    	while(SOCResourceSet.gte(resources,SOCGame.CITY_SET)){
    		resources.subtract(SOCGame.CITY_SET);
    		maxCities++;
    	}
    	maxCities= Math.min(maxCities,PlayerData.getNumPieces(SOCPlayingPiece.CITY));
    	
    	resources= PlayerData.getResources().copy();
    	int maxDevCards=0;
    	while(SOCResourceSet.gte(resources,SOCGame.CARD_SET)){
    		resources.subtract(SOCGame.CARD_SET);
    		maxDevCards++;
    	}    
    	maxDevCards= Math.min(maxDevCards,game.getNumDevCards());
    	
    	// building combos contains an array for each possible combination of number
    	// of each type of thing to be built
    	// e.g. [0 1 0 0] [1 1 0 0] [2 0 0 0] [1 0 0 0] [0 0 0 0] means:
    	// nothing built, or 1 road, or 2 roads, or 1 road 1 settlement, or 1 settlement 
    	Vector<int[]> buildingCombos= new Vector<int[]>();
    	
    	resources= PlayerData.getResources().copy();
    	for(int r=0; r<maxRoads; r++){
    		SOCResourceSet roads= SOCGame.ROAD_SET.copy();
    		roads.times(r);
    		for(int s=0; s<maxSettlements; s++){
    			SOCResourceSet settlements= SOCGame.SETTLEMENT_SET.copy();
        		settlements.times(s);
    			for(int c=0; c<maxCities; c++){
    				SOCResourceSet cities= SOCGame.CITY_SET.copy();
    	    		cities.times(c);
    				for(int d=0; d<maxDevCards; d++){
    					SOCResourceSet dCards= SOCGame.CARD_SET.copy();
    		    		roads.times(d);
    		    		
    		    		dCards.add(roads);
    		    		dCards.add(settlements);
    		    		dCards.add(cities);
    		    		
    		    		// we get a settlement back to use when we build a city
    		    		if(SOCResourceSet.gte(resources,dCards) && s-c<=remainingSettlements){
    		    			int [] combo= new int[] {r, s, c, d};
    		    			buildingCombos.add(combo);
    		    		}
    					
    				}
    			}
    		}
    	}
    	
    	
    	
    	boolean[] portFlags= PlayerData.getPortFlags();
    	
        boolean[] to= new boolean[game.maxPlayers];
    	for (int i = 0; i < game.maxPlayers; i++)
        {
            to[i] = false;
        }

        SOCTradeOffer bankTrade = new SOCTradeOffer(game.getName(), PlayerData.getPlayerNumber(), to, give, get);

       return moves;    	
    	
    }
    
    
    
    /** will hold weight information for evaluation function */
    float [] weights;
    
    /** Added by Katie
     * returns a float estimated value of the current board state
     * 
     * number of settlements
		number of cities
		number of each type of resource
		have a 3:1 port?
		number of each type of unplayed dev card
		Expected number of each type of resource per turn
		Expected number of each type of resource per turn for each 2:1 port owned
		have largest army?
		size of largest army- size of our army +1
		have longest road?
		length of longest road- length of our longest road +1
		number spots available to build settlements
		number spots available to build roads?
		
		ditto for opponent
     * 
     */
    protected float evaluateBoard(){
    	int numSettlements= ourPlayerData.getSettlements().size();
    	int numCities= ourPlayerData.getCities().size();
    	int haveMiscPort= (ourPlayerData.getPortFlag(SOCBoard.MISC_PORT)? 1:0);
    	int[] devCards= ourPlayerData.getDevCards().getTotalTypes();
    	double[] expectedResources= ourPlayerData.expectedNumResources();
    	boolean[] portFlags= ourPlayerData.getPortFlags();
    	int hasArmy= ourPlayerData.hasLargestArmy()?1:0;
    	int knightDifference= game.getPlayerWithLargestArmy().getNumKnights()-ourPlayerData.getNumKnights();
    	int hasRoad= ourPlayerData.hasLongestRoad()?1:0;
    	int roadDif= game.getPlayerWithLongestRoad().getLongestRoadLength()-ourPlayerData.getLongestRoadLength();
    	int potentialSettlements= ourPlayerData.numPotentialSettlements();
    	int potentialRoads= ourPlayerData.numPotentialRoads();
    	
    	SOCPlayer[] players= game.getPlayers();
    	SOCPlayer opp= players[0];
    	for(int i=1; i<players.length; i++){
    		if (players[i].getPlayerNumber()!=ourPlayerData.getPlayerNumber()){
    			opp= players[i];
    		}
    	}
    	
    	int theirSettlements= opp.getSettlements().size();
    	int theirCities= opp.getCities().size();
    	int theirMiscPort= (opp.getPortFlag(SOCBoard.MISC_PORT)? 1:0);
    	int theirDevCards= opp.getDevCards().getTotal(); // don't know the type
    	double[] theirExpectedResources= opp.expectedNumResources();
    	boolean[] theirPortFlags= opp.getPortFlags();
    	int theirArmy= opp.hasLargestArmy()?1:0;
    	int theirKnightDifference= game.getPlayerWithLargestArmy().getNumKnights()-opp.getNumKnights();
    	int theirHasRoad= opp.hasLongestRoad()?1:0;
    	int theirRoadDif= game.getPlayerWithLongestRoad().getLongestRoadLength()-opp.getLongestRoadLength();
    	int theirPotentialSettlements= opp.numPotentialSettlements();
    	int theirPotentialRoads= opp.numPotentialRoads();
    	
    	return 0.0;
    	
    	/*
    	float[] features= new float[50];
    	int ind=0;
    	features[ind++]= numSettlements;
    	features[ind++]= numCities;
    	features[ind++]= haveMiscPort;
    	for(int i=0; i<devCards.length; i++)
    		features[ind++]= devCards[i];
    	for(int i=0; i<expectedResources.length; i++)
    		features[ind++]= expectedResources[i];
    	*/
    }
    
}
