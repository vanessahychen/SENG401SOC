package soc.ourRobot;

import soc.client.SOCDisplaylessPlayerClient;
import soc.disableDebug.D;

import soc.robot.SOCBuildingSpeedEstimate;
import soc.robot.SOCPossibleCard;
import soc.robot.SOCPossibleCity;
import soc.robot.SOCPossibleSettlement;
import soc.robot.SOCRobotBrain;
import soc.robot.SOCRobotNegotiator;
import soc.robot.SOCRobotClient;
import soc.robot.SOCPossiblePiece;
import soc.robot.SOCPossibleRoad;

import soc.game.SOCBoard;
import soc.game.SOCCity;
import soc.game.SOCDevCardConstants;
import soc.game.SOCDevCardSet;
import soc.game.SOCGame;
import soc.game.SOCPlayer;
import soc.game.SOCPlayerNumbers;
import soc.game.SOCPlayingPiece;
import soc.game.SOCResourceConstants;
import soc.game.SOCResourceSet;
import soc.game.SOCRoad;
import soc.game.SOCSettlement;
import soc.game.SOCTradeOffer;

import soc.message.SOCAcceptOffer;
import soc.message.SOCCancelBuildRequest;
import soc.message.SOCChoosePlayerRequest;
import soc.message.SOCClearOffer;
import soc.message.SOCDevCard;
import soc.message.SOCDevCardCount;
import soc.message.SOCDiceResult;
import soc.message.SOCDiscardRequest;
import soc.message.SOCFirstPlayer;
import soc.message.SOCGameState;
import soc.message.SOCGameTextMsg;
import soc.message.SOCMakeOffer;
import soc.message.SOCMessage;
import soc.message.SOCMoveRobber;
import soc.message.SOCPlayerElement;
import soc.message.SOCPotentialSettlements;
import soc.message.SOCPutPiece;
import soc.message.SOCRejectOffer;
import soc.message.SOCResourceCount;
import soc.message.SOCSetPlayedDevCard;
import soc.message.SOCSetTurn;
import soc.message.SOCTurn;

import soc.server.SOCServer;

import soc.util.CappedQueue;
import soc.util.CutoffExceededException;
import soc.util.DebugRecorder;
import soc.util.Queue;
import soc.util.SOCRobotParameters;
import java.util.*;


public class SOCOurBrain extends SOCRobotBrain {
	
	/** Strategy we are playing in this game
	 * 
	 *  0 = Balanced, 1 = Roads/Settlements, 2 = Cities/Development Cards
	 */
	private int strategy;
	
	static final float[] FPROB = 
    {
        0.0f, 0.0f, 0.03f, 0.06f, 0.08f, 0.11f, 0.14f, 0.17f, 0.14f, 0.11f,
        0.08f, 0.06f, 0.03f
    };
	
	static final double[] PROB = 
    {
        0.0, 0.0, 0.03, 0.06, 0.08, 0.11, 0.14, 0.17, 0.14, 0.11,
        0.08, 0.06, 0.03
    };
	
	 private final int cityWeight= 5;
	 private final int settlementWeight= 3;
	 private final int roadWeight= 1;
	 private final int devCardWeight= 2; // should depend on strategy

	/**
     * Create a robot brain to play a game.
     *<P>
     * Depending on {@link SOCGame#getGameOptions() game options},
     * constructor might copy and alter the robot parameters
     * (for example, to clear {@link SOCRobotParameters#getTradeFlag()}).
     *
     * @param rc  the robot client
     * @param params  the robot parameters
     * @param ga  the game we're playing
     * @param mq  the message queue
     */
    public SOCOurBrain(SOCRobotClient rc, SOCRobotParameters params, SOCGame ga, CappedQueue mq)
    {
    	super(rc, params, ga, mq);
    }
 
 
	 /**
	  * Current Trading AI
	  * Rejects all offers
	  */
	 protected int considerOffer(SOCTradeOffer offer)
	 {
	     return SOCRobotNegotiator.REJECT_OFFER;
	 }
	 
	 /**
	     * figure out where to place the two settlements
	     */
	    
	    protected void planInitialSettlements()
	    {
	    	double bestScore = 0.0;
	    	double secondBestScore = 0.0;
	    	firstSettlement = -1;
	    	secondSettlement = -1;
	    	SOCBoard board = game.getBoard();
	    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
	        {
	            if (ourPlayerData.isPotentialSettlement(firstNode))
	            {
	            	double currentScore = 0.0;
	                Integer nodeInt = new Integer(firstNode);
	                Enumeration hexes = SOCBoard.getAdjacentHexesToNode(firstNode).elements();
	                
	                while (hexes.hasMoreElements())
	                {
	                    Integer hex = (Integer) hexes.nextElement();
	                    int number = board.getNumberOnHexFromCoord(hex.intValue());
	                    currentScore += PROB[number];
	                }
	                if(firstSettlement == -1 || currentScore > bestScore) {
	                	secondSettlement = firstSettlement;
	                	firstSettlement = nodeInt;
	                	secondBestScore = bestScore;
	                	bestScore = currentScore;
	                }
	                else if(secondSettlement == -1 || currentScore > secondBestScore) {
	                	secondSettlement = nodeInt;
	                	secondBestScore = currentScore;
	                }
	            }
	        }
	    }

	    /**
	     * figure out where to place the second settlement
	     */
	    protected void planSecondSettlement()
	    {
	    	//client.sendText(game,"placing our second settlement.");
	    	if(ourPlayerData.isPotentialSettlement(secondSettlement))
	    		return;
	    		
	    	double bestScore = 0.0;
	    	secondSettlement = -1;
	    	SOCBoard board = game.getBoard();
	    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
	        {
	            if (ourPlayerData.isPotentialSettlement(firstNode))
	            {
	            	double currentScore = 0.0;
	                Integer nodeInt = new Integer(firstNode);
	                Enumeration hexes = SOCBoard.getAdjacentHexesToNode(firstNode).elements();
	                
	                while (hexes.hasMoreElements())
	                {
	                    Integer hex = (Integer) hexes.nextElement();
	                    int number = board.getNumberOnHexFromCoord(hex.intValue());
	                    currentScore += PROB[number];
	                }
	                if(secondSettlement == -1 || currentScore > bestScore) {
	                	secondSettlement = nodeInt;
	                	bestScore = currentScore;
	                }
	            }
	        }
	    }

	    /**
	     * place planned first settlement
	     */
	    protected void placeFirstSettlement()
	    {
	        //D.ebugPrintln("BUILD REQUEST FOR SETTLEMENT AT "+Integer.toHexString(firstSettlement));
	        //pause(500);
	        lastStartingPieceCoord = firstSettlement;
	        client.putPiece(game, new SOCSettlement(ourPlayerData, firstSettlement, null));
	        //pause(1000);
	    }

	    /**
	     * place planned second settlement
	     */
	    protected void placeSecondSettlement()
	    {
	        if (secondSettlement == -1)
	        {
	            // This could mean that the server (incorrectly) asked us to
	            // place another second settlement, after we've cleared the
	            // potentialSettlements contents.
	            System.err.println("robot assert failed: secondSettlement -1, " + ourPlayerData.getName() + " leaving game " + game.getName());
	            failedBuildingAttempts = 2 + (2 * MAX_DENIED_BUILDING_PER_TURN);
	            waitingForGameState = false;
	            return;
	        }

	        //D.ebugPrintln("BUILD REQUEST FOR SETTLEMENT AT "+Integer.toHexString(secondSettlement));
	        //pause(500);
	        lastStartingPieceCoord = secondSettlement;
	        client.putPiece(game, new SOCSettlement(ourPlayerData, secondSettlement, null));
	       // pause(1000);
	    }

	    /**
	     * Plan and place a road attached to our most recently placed initial settlement,
	     * in game states {@link SOCGame#START1B START1B}, {@link SOCGame#START2B START2B}.
	     *<P>
	     * Road choice is based on the best nearby potential settlements, and doesn't
	     * directly check {@link SOCPlayer#isPotentialRoad(int) ourPlayerData.isPotentialRoad(edgeCoord)}.
	     * If the server rejects our road choice, then {@link #cancelWrongPiecePlacementLocal(SOCPlayingPiece)}
	     * will need to know which settlement node we were aiming for,
	     * and call {@link SOCPlayer#clearPotentialSettlement(int) ourPlayerData.clearPotentialSettlement(nodeCoord)}.
	     * The {@link #lastStartingRoadTowardsNode} field holds this coordinate.
	     */
	    public void placeInitRoad()
	    {
	    	//client.sendText(game,"Placing our road.");
	        final int settlementNode = ourPlayerData.getLastSettlementCoord();

	        int[] choices = game.getBoard().getAdjacentEdgesToNode_arr(settlementNode);
	    	
	    	//randomly pick road direction
	        int rand = (int)(Math.random()*(3));
	        
	        //Pick based on possible future progress
			int bestSpot = choices[0];
			float bestVal = -1;
			float curVal = -1;
	    	for (int i=0;i < 3;i++) {
	    		if(choices[i] != -1) {
	    			Vector<Integer> nextRoads = game.getBoard().getAdjacentEdgesToEdge(choices[i]);
	    			for (int j=0;j<nextRoads.size();j++) {
	        			if(nextRoads.get(j) != -1) {
	        				Vector<Integer> nextNodes = game.getBoard().getAdjacentNodesToEdge(nextRoads.get(j));
	        				for (int k=0;k<nextNodes.size();k++) {
	        					if (ourPlayerData.isPotentialSettlement(nextNodes.get(k))) {
	        						Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(nextNodes.get(k));
	        						curVal = 0;
	        						for(int l=0;l<adjHexes.size();l++) {
	        							curVal = curVal + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(l))];
	        						}
	        						if (curVal > bestVal) {
	        							bestVal = curVal;
	        							bestSpot = choices[i];
	        						}
	        					}
	        				}
	        			}
	        		}
	    		}
	    	}
	    	
	    	//random
	    	int roadEdge = choices[rand];
	    	//"best"
	    	// int roadEdge = bestSpot;
	    	
	    	int[] endPoints = game.getBoard().getAdjacentNodesToEdge_arr(roadEdge);
	    	int destination = endPoints[0];
	    	if(destination == settlementNode)
	    		destination = endPoints[1];
	    	
	        //D.ebugPrintln("!!! PUTTING INIT ROAD !!!");
	        //pause(500);

	        //D.ebugPrintln("Trying to build a road at "+Integer.toHexString(roadEdge));
	        lastStartingPieceCoord = roadEdge;
	        lastStartingRoadTowardsNode = destination;
	        client.putPiece(game, new SOCRoad(ourPlayerData, roadEdge, null));
	       // pause(1000);
	    }
	
    
    
    /** Returns a ranking of the given resource set based on how much can be built
     * using it. Does not consider bank trades.
     * Different constructs are given different weights, using tunable parameters.
     *  
     * @param set SOCResourceSet to rank
     * @return ranking of this set
     */
    private int rankResourceSet(SOCResourceSet set){
    	//int city, settl, rd, card;
    	//max(cityWeight*city+settlementWeight*settl+roadWeight*rd+devCardWeight*dev);
    	//s.t. resource constraints
    	
    	int rank=0;
    	while(SOCResourceSet.gte(set,SOCGame.CITY_SET)){
    		set.subtract(SOCGame.CITY_SET);
    		rank+=cityWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.SETTLEMENT_SET)){
    		set.subtract(SOCGame.SETTLEMENT_SET);
    		rank+=settlementWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.CARD_SET)){
    		set.subtract(SOCGame.CARD_SET);
    		rank+=devCardWeight;
    	}
    	while(SOCResourceSet.gte(set,SOCGame.ROAD_SET)){
    		set.subtract(SOCGame.ROAD_SET);
    		rank+=roadWeight;
    	}
    	
    	return rank;
    }
    
    
    /** Decide whether or not to accept a given trade offer
     *  Will accept an offer if something additional can be built
     * @param offer the SOCTradeOffer offered to the robot
     * @return true if the trade should be accepted
     */
    
    protected boolean considerOffer2(SOCTradeOffer offer){
    	// int opp= offer.getFrom(); // opponent offering the trade
    	SOCResourceSet offered= offer.getGiveSet();
    	SOCResourceSet exchange= offer.getGiveSet();
    	SOCResourceSet current= ourPlayerData.getResources();
    	// return false if we cannot make the trade
    	if(!SOCResourceSet.gte(current,exchange)) return false;
    	// oldRank
    	int prevRank= rankResourceSet(current);
    	SOCResourceSet updated= current.copy();
    	updated.subtract(exchange);
    	updated.add(offered);
    	// current holds the new amount of resources
    	int newRank= rankResourceSet(updated);  	 
    	return newRank>prevRank;
    }
    
        
    
    protected void getDiscoveryResources(){
    	//SOCResourceSet current= player.getResources();
    	resourceChoices= new SOCResourceSet(2,0,0,0,0,0); // always request 2 clay for now
    }
    
    
    /**
     * Choose which resource we want to monopolize
     */
    protected void getMonopolyResources(){
    	monopolyChoice= SOCResourceConstants.ORE; // for now just pick ore
    }
    
    /** Decide whether or not to play a dev card during a turn
     * @param none
     * @return 
     */
    protected void playDevCards(){
    	//SOCDevCardSet
    	SOCDevCardSet cards = ourPlayerData.getDevCards();
    	if(cards.getNumUnplayed()==0) return;
    	int vptot= ourPlayerData.getTotalVP();
    	// Play victory point cards if we can win
    	if(vptot==10){
    		//TODO fix this
    		// play all vp cards
    		for(int i=SOCDevCardConstants.CAP;i<SOCDevCardConstants.TOW;i++){
    			if(cards.getAmount(SOCDevCardSet.OLD,i)>0){
    				client.playDevCard(game, i);
    	    	}
    		}
    		return;
    	}
    	// Play Knight card if we are threatened by robber
    	if(robberThreatening() && cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.KNIGHT)>0){
    		client.playDevCard(game, SOCDevCardConstants.KNIGHT);
    		return;
    	}
    	// Play Roads card if we have one
    	if(cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.ROADS)>0){
    		client.playDevCard(game, SOCDevCardConstants.ROADS);
    		return;
    	}
    	// Play discovery card if we have one
    	if(cards.getAmount(SOCDevCardSet.OLD,SOCDevCardConstants.DISC)>0){
    		getDiscoveryResources();
    		client.playDevCard(game, SOCDevCardConstants.DISC);
    		return;
    	}
    	if(cards.getAmount(SOCDevCardSet.OLD, SOCDevCardConstants.MONO)>0){
    		getMonopolyResources();
    		client.playDevCard(game, SOCDevCardConstants.MONO);
    		return;
    	}
    	
   }
    
    /** Indicates whether player is currently threatened by robber
     * 
     * @return true if robber adjacent to one of our settlements/cities, false otherwise
     */
    private boolean robberThreatening(){
    	SOCBoard board= game.getBoard();
    	int robHex= board.getRobberHex();
    	Vector threatened= game.getPlayersOnHex(robHex);
    	return threatened.contains(ourPlayerData.getPlayerNumber());
    }
    
    // Added by Ryan
    // Discards numDiscards resources at random
    // TODO Placeholder for real discard method
    protected void discard(int numDiscards) {
    	SOCResourceSet discards = new SOCResourceSet();
    	SOCGame.discardPickRandom(ourPlayerData.getResources(), numDiscards, discards, rand);
        client.discard(game, discards);
    }
    
    // Added by Ryan
    // Tries to build, in order: City, Settlement, Road, Dev Card
    // TODO Placeholder for real planBuilding()
    protected void planBuilding()
    {
    	
    	//this.client.sendText(this.game, " planning building.");
        buildingPlan.clear();
    	
       buildingPlan.push(new SOCPossibleCard(ourPlayerData, 1));
        
        
        
    	for(int i=0; i<=game.getBoard().MAXEDGE; i++) {
        	if(ourPlayerData.isPotentialRoad(i)) {
        		buildingPlan.push(new SOCPossibleRoad(ourPlayerData, i, new Vector()));
        		break;
        	}
        }
        
        for(int i=0; i<=game.getBoard().MAXNODE; i++) {
        	if(ourPlayerData.isPotentialSettlement(i)) {
        		buildingPlan.push(new SOCPossibleSettlement(ourPlayerData, i, new Vector()));
        		break;
        	}
        }
        
        for(int i=0; i<=game.getBoard().MAXNODE; i++) {
        	if(ourPlayerData.isPotentialCity(i)) {
        		buildingPlan.push(new SOCPossibleCity(ourPlayerData, i));
        		break;
        	}
        }
        
        
        if(!buildingPlan.empty())
        	lastTarget = (SOCPossiblePiece) buildingPlan.peek();
    }
    
    /*
    protected void tradeWithBank(){
    	Vector settlements= ourPlayerData.getSettlements();
    	Vector cities= ourPlayerData.getCities();
    	boolean havePort= false;
    	for(int i=0; i<settlements.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i=0; i<cities.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i= 0; i<=SOCResourceConstants.WOOD; i++){
    		int numRes= ourPlayerData.getResources().getAmount(i);
    		SOCResourceSet give= new SOCResourceSet();
    		SOCResourceSet get= new SOCResourceSet();
    		get.add(1,(i+1)%SOCResourceConstants.WOOD);
    		if(numRes>=3 && havePort){
    			give.add(3,i);
    			client.bankTrade(game,give,get);   			
    		} else if(numRes>=4){
    			give.add(4,i);
    			client.bankTrade(game,give, get);
    		}
    		
    	}
    	
    }
    */
    
    // Added by Ryan
    protected void buildOrGetResourceByTradeOrCard() {
    	//printResources();
    	//int nextPlayer= ourPlayerData.getPlayerNumber()== 3? 1: ourPlayerData.getPlayerNumber()-1;
    	/*SOCPlayer opp= game.getPlayers()[0];
    	SOCResourceSet set= opp.getResources();
    	int unk= set.getAmount(SOCResourceConstants.UNKNOWN);
    	String str= "Player " + opp.getName()+" has "+set.toFriendlyString()+ " unknown: " +unk;
    	client.sendText(this.game, str);
    	pause(1500);*/
    	
    	// Build the "best" thing we can buy/trade for (City > Settlement > Road > Card)
    	//this.client.sendText(this.game, " starting building.");
    	if(buildingPlan.empty())
    		return;
    	//this.client.sendText(this.game, " have something to build.");
    	while(!buildingPlan.empty()) {
	    	SOCPossiblePiece targetPiece = (SOCPossiblePiece) buildingPlan.peek();
	    	SOCResourceSet cost = SOCPlayingPiece.getResourcesToBuild(targetPiece.getType());
	    	
	    	//this.client.sendText(this.game, " evaluating a "+targetPiece.toFriendlyString());
	    	
	    	// Check to see if we need to trade, and wait for the transaction if we do
	    	// Modified by Katie
	    	SOCTradeOffer trade= tradeWithBank(cost, game, ourPlayerData.getPlayerNumber());
	    	if (trade!=null)
	        {
	    		client.bankTrade(game, trade.getGiveSet(), trade.getGetSet());
	            counter = 0;
	            waitingForTradeMsg = true;
	            pause(1500);
	        }
	    	
	    	if (!waitingForTradeMsg && !waitingForTradeResponse && ourPlayerData.getResources().contains(cost))
	        {
	    		//this.client.sendText(this.game, " trying to build a "+targetPiece.toFriendlyString());
	    		buildRequestPlannedPiece(targetPiece);
	            return;
	        }
	    	else if (!ourPlayerData.getResources().contains(cost)) {
	    		buildingPlan.pop();
	    	}
    	}
    	
    	// The below code may build more than one thing; let's just build one for now.
    	/*
    	int buildCount = 0;
    	
    	
    	if(!buildingPlan.isEmpty() && SOCResourceSet.gte(ourPlayerData.getResources(),SOCGame.CITY_SET) 
    			&& buildingPlan.peek() instanceof SOCPossibleCity){
    		targetPiece = (SOCPossibleCity) buildingPlan.pop();
      		 whatWeWantToBuild= new SOCCity(ourPlayerData, targetPiece.getCoordinates(), null);
      		 waitingForGameState = true;
               counter = 0;
               expectPLACING_CITY = true;
               buildCount++;
               //client.buildRequest(game, targetPiece.getType());
               //return;
       	}
    	else {
    		while(!buildingPlan.isEmpty() && buildingPlan.peek() instanceof SOCPossibleCity)
    			buildingPlan.pop();
    	}
    		
    	if(!buildingPlan.isEmpty() && buildCount == 0){
    		if(SOCResourceSet.gte(ourPlayerData.getResources(),SOCGame.SETTLEMENT_SET)
    				&& buildingPlan.peek() instanceof SOCPossibleSettlement){
    			targetPiece = (SOCPossibleSettlement) buildingPlan.pop();
    			whatWeWantToBuild= new SOCSettlement(ourPlayerData, targetPiece.getCoordinates(), null);
    			waitingForGameState = true;
    			counter = 0;
    			expectPLACING_SETTLEMENT = true;
    			buildCount++;
    			//client.buildRequest(game, targetPiece.getType());
    			//return;
    		}
    		else
    			while(!buildingPlan.isEmpty() && buildingPlan.peek() instanceof SOCPossibleSettlement)
    				buildingPlan.pop();
    	}
    			
    	
    	if(!buildingPlan.isEmpty() && buildCount == 0) {
    		if(SOCResourceSet.gte(ourPlayerData.getResources(),SOCGame.ROAD_SET)
    				&& buildingPlan.peek() instanceof SOCPossibleRoad){
    			targetPiece = (SOCPossibleRoad) buildingPlan.pop();
    			whatWeWantToBuild= new SOCRoad(ourPlayerData, targetPiece.getCoordinates(), null);
    			waitingForGameState = true;
    			counter = 0;
    			expectPLACING_ROAD = true;
    			//client.buildRequest(game, targetPiece.getType());
    		}
    	 }
    	 */

    	/*
    	if(targetPiece != null)
    		client.buildRequest(game, targetPiece.getType());
    		*/
    }
    
    /** Moves the robber when a seven is rolled (Nick)
     * 
     */
    protected void moveRobber() {
    	//Find the best hex to place the robber
    	int current = game.getBoard().getRobberHex();
		int [] board = game.getBoard().getHexLandCoords();
		int bestSpot = current;
		float bestVal = -1;
		float curVal = -1;
		for(int i=0;i<board.length;i++) {
			//Don't rank hex if ours or current robber hex
			if(ourPlayerData.getNumbers().getNumberResourcePairsForHex(board[i]).isEmpty() && board[i] != current) {
				curVal = FPROB[(game.getBoard().getNumberOnHexFromNumber(board[i]))]*rankHexValue(board[i]);
				//If value is higher, this becomes our best spot
				if (curVal > bestVal) {
					bestVal = curVal;
					bestSpot = board[i];
				}
			}
		}
		client.moveRobber(game, ourPlayerData, bestSpot);
	}
    
    /**
     * Chooses victim with most confirmed VPs, or most resources if VPs are equal
     */
    protected void chooseRobberVictim(boolean[] choices) {
    	int choice = -1;
    	for (int i = 0; i < game.maxPlayers; i++)
        {
            if (! game.isSeatVacant (i))
            {
                if (choices[i])
                {
                    if (choice == -1)
                    {
                        choice = i;
                    }
                    else
                    {
                        SOCPlayer current = game.getPlayer(i);
                        SOCPlayer best = game.getPlayer(choice);
                        
                    	if (current.getPublicVP() > best.getPublicVP()) {
                			choice = i;
                		} else if (current.getPublicVP() == best.getPublicVP()) {
                			if (current.getResources().getTotal() > best.getResources().getTotal()) {
                				choice = i;
                			}
                		}
                    }
                }
            }
        }
    	
    	client.choosePlayer(game, choice);
    }
    
    /** Returns the value given of a hex based on what is built there (Nick)
     * Rank: 	1 point for settlements
     * 			2 points for cities
     * 
     * @param hex coordinates of the hex to find the value of
     * @return value of the hex
     */
    private int rankHexValue(int hex) {
    	int val = 0;
    	for(int i=0;i<6;i++) {
    		SOCPlayingPiece piece = game.getBoard().settlementAtNode(game.getBoard().getAdjacentNodeToHex(hex,i));
    		if (piece instanceof SOCCity) {
    			val = val+2;
    		} else if (piece instanceof SOCSettlement) {
    			val = val+1;
    		}
    	}
    	return val;
    }
    
    /** Returns the player ID of the player to steal from (Nick)
     * 
     * @param hex coordinates of the hex to find the value of
     * @return player ID
     */
    // TODO Ryan: added the AI in this method to chooseRobberVictim(boolean[] choices) above
    private int playerToStealFrom(int hex) {
    	//Possible players
    	ArrayList<SOCPlayer> possible = new ArrayList<SOCPlayer>();
    	for(int i=0;i<6;i++) {
    		SOCPlayingPiece piece = game.getBoard().settlementAtNode(game.getBoard().getAdjacentNodeToHex(hex,i));
    		if (piece != null && !possible.contains(piece.getPlayer())) {
    			possible.add(piece.getPlayer());
    		}
    	}
    	//Select the best player
    	SOCPlayer best = possible.get(0);
    	SOCPlayer current;
    	for (int i=1;i<3;i++) {
    		current = possible.get(i);
    		if (current.getPublicVP() > best.getPublicVP()) {
    			best = current;
    		} else if (current.getPublicVP() == best.getPublicVP()) {
    			if (current.getResources().getTotal() > best.getResources().getTotal()) {
    				best = current;
    			}
    		}
    	}
    	return best.getPlayerNumber();
    }
    
    /** Returns the possible settlements a player can build (Nick)
     * 
     * @return Hash-table with probabilities as keys for node coordinates
     */
    protected Hashtable<Float,Integer> possibleSettlementSpots() {
    	Hashtable<Float,Integer> nodeProbPairs = new Hashtable<Float,Integer>();
		
    	//Go through each node on the board adding those that are legal
    	for (int i=SOCBoard.MINNODE; i<SOCBoard.MAXNODE;i++) {
			if(ourPlayerData.isPotentialSettlement(i)) {
				Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(i);
				Float current = 0f;
				for(int j=0;j<adjHexes.size();j++) {
					current = current + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(i))];
				}
				// Add rarity index here (current version prevents hash collision)
				if (!nodeProbPairs.containsValue(current)) {
					nodeProbPairs.put(current,i);
				} else {
					nodeProbPairs.put(current + 0.0001f, i);
				}
			}
    	}
    	return nodeProbPairs;
    }
    
    /** Chooses the first settlement during the initial set-up phase (Nick)
     * 
     */
    protected void pickFirstSettlement() {
    	strategy = 0;
    	
    	//Obtain possible settlements
    	/*
    	Hashtable<Float,Integer> possible = possibleSettlementSpots();
    	Float[] probs = possible.keySet().toArray(new Float[1]);
    	Arrays.sort(probs);	    	
    	
    	//Choose best option
    	client.putPiece(game, new SOCSettlement(ourPlayerData,possible.get(probs[0]),null));
    	*/
    	
    	// Just testing this out...
    	
    	//identify settlement
    	double bestScore = 0.0;
    	firstSettlement = -1;
    	SOCBoard board = game.getBoard();
    	for (int firstNode = board.getMinNode(); firstNode <= SOCBoard.MAXNODE; firstNode++)
        {
            if (ourPlayerData.isPotentialSettlement(firstNode))
            {
            	double currentScore = 0.0;
                Integer firstNodeInt = new Integer(firstNode);
                Vector<Integer> hexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(firstNode).elements();
                for(Integer i: hexes) {
                	currentScore += PROB[i];
                }
                if(firstSettlement == -1 || currentScore < bestScore) {
                	firstSettlement = firstNodeInt;
                }
            }
        }
    	
    	//place it
    	gameStrategy(firstSettlement,null);
    	//pause(500);
        lastStartingPieceCoord = firstSettlement;
        client.putPiece(game, new SOCSettlement(ourPlayerData, firstSettlement, null));
        //pause(1000);
    }
    
    /** Chooses the second settlement during the initial set-up phase (Nick)
     * 
     */
    protected void pickSecondSettlement() {
    	//Obtain possible settlements
    	/*
    	Hashtable<Float,Integer> possible = possibleSettlementSpots();
    	Float[] probs = possible.keySet().toArray(new Float[1]);
    	Arrays.sort(probs);	    	
    	
    	//Choose best option
    	client.putPiece(game, new SOCSettlement(ourPlayerData,possible.get(probs[0]),null));
    	*/
    	
// Just testing this out...
    	
    	//identify settlement
    	double bestScore = 0.0;
    	secondSettlement = -1;
    	SOCBoard board = game.getBoard();
    	for (int secondNode = board.getMinNode(); secondNode <= SOCBoard.MAXNODE; secondNode++)
        {
            if (ourPlayerData.isPotentialSettlement(secondNode))
            {
            	double currentScore = 0.0;
                Integer secondNodeInt = new Integer(secondNode);
                Vector<Integer> hexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(secondNode).elements();
                for(Integer i: hexes) {
                	currentScore += PROB[i];
                }
                if(secondSettlement == -1 || currentScore < bestScore) {
                	secondSettlement = secondNodeInt;
                }
            } 
        }
    	
    	//place it
    	gameStrategy(firstSettlement,secondSettlement);
    	//pause(500);
        lastStartingPieceCoord = secondSettlement;
        client.putPiece(game, new SOCSettlement(ourPlayerData, secondSettlement, null));
        //pause(1000);
    }
    
    /** Chooses where to build roads during the initial set-up phase (Nick)
     * 
     * @param node coordinate where the road must start from
     */
    protected void pickInitialRoad(int node) {
    	int[] choices = game.getBoard().getAdjacentEdgesToNode_arr(node);
    	
    	//randomly pick road direction
        int rand = (int)(Math.random()*(3));
        
        //Pick based on possible future progress
		int bestSpot = choices[0];
		float bestVal = -1;
		float curVal = -1;
    	for (int i=0;i < 3;i++) {
    		if(choices[i] != -1) {
    			Vector<Integer> nextRoads = game.getBoard().getAdjacentEdgesToEdge(choices[i]);
    			for (int j=0;j<nextRoads.size();j++) {
        			if(nextRoads.get(j) != -1) {
        				Vector<Integer> nextNodes = game.getBoard().getAdjacentNodesToEdge(nextRoads.get(j));
        				for (int k=0;k<nextNodes.size();k++) {
        					if (ourPlayerData.isPotentialSettlement(nextNodes.get(k))) {
        						Vector<Integer> adjHexes = SOCBoard.getAdjacentHexesToNode(nextNodes.get(k));
        						curVal = 0;
        						for(int l=0;l<adjHexes.size();l++) {
        							curVal = curVal + FPROB[game.getBoard().getNumberOnHexFromNumber(adjHexes.get(l))];
        						}
        						if (curVal > bestVal) {
        							bestVal = curVal;
        							bestSpot = choices[i];
        						}
        					}
        				}
        			}
        		}
    		}
    	}
    	
    	client.putPiece(game, new SOCRoad(ourPlayerData,choices[rand],null));
    	//client.putPiece(game, new SOCRoad(player,bestSpot,null));
    }
 
    /** Returns the rarity index (probability distribution) for resources on the board (Nick)
     * 
     * @return Vector of float probabilities with indexes(in order): Other, Clay, Ore, Sheep, Wheat, Wood
     */
    private Vector<Float> rarityIndex() {
		Vector<Float> index = new Vector<Float>();
		for(int i=0;i<6;i++) {
			index.add(i, 0f);
		}
		int [] board = game.getBoard().getHexLandCoords();
		for(int i=0;i<board.length;i++) {
			float curProb = FPROB[game.getBoard().getNumberOnHexFromNumber(board[i])];
			switch (game.getBoard().getHexTypeFromCoord(board[i])) {
				case SOCResourceConstants.CLAY:
					index.set(SOCResourceConstants.CLAY, index.get(SOCResourceConstants.CLAY)+curProb);
					break;
				case SOCResourceConstants.ORE:
					index.set(SOCResourceConstants.ORE, index.get(SOCResourceConstants.ORE)+curProb);
					break;
				case SOCResourceConstants.SHEEP:
					index.set(SOCResourceConstants.SHEEP, index.get(SOCResourceConstants.SHEEP)+curProb);
					break;	
				case SOCResourceConstants.WHEAT:
					index.set(SOCResourceConstants.WHEAT, index.get(SOCResourceConstants.WHEAT)+curProb);
					break;
				case SOCResourceConstants.WOOD:
					index.set(SOCResourceConstants.WOOD, index.get(SOCResourceConstants.WOOD)+curProb);
					break;
				default:
					//Add all other hexes to first index for debugging purposes
					index.set(0, index.get(0)+curProb);
			}
		}
		return index;
    }
    
    /** Sets the game strategy for our agent using a combination of rarity index and settlements available (Nick)
     * 
     * @param firstSettlement node coordinates of first settlement location
     * @param secondSettlement node coordinates of second settlement location (null if only first chosen)
     */
    private void gameStrategy(int firstSettlement, Integer secondSettlement) {
    	Vector<Float> rarity = rarityIndex();
    	Vector<Integer> firstHexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(firstSettlement);
    	Integer temp = firstHexes.get(0);
    	if (PROB[game.getBoard().getNumberOnHexFromCoord(firstHexes.get(0))] > FPROB[game.getBoard().getNumberOnHexFromCoord(firstHexes.get(1))]) {
    		temp = firstHexes.get(1);
    	} else {
    		temp = firstHexes.get(2);
    	}
    	switch (game.getBoard().getHexTypeFromCoord(temp)) {
		case SOCResourceConstants.CLAY:
			strategy = 1;
			break;
		case SOCResourceConstants.ORE:
			strategy = 2;
			break;
		case SOCResourceConstants.SHEEP:
			strategy = 0;
			break;	
		case SOCResourceConstants.WHEAT:
			strategy = 2;
			break;
		case SOCResourceConstants.WOOD:
			strategy = 1;
			break;
		default:
			//Add all other hexes to first index for debugging purposes
			strategy = 0;
	}
    	/*
    	if(secondSettlement != null) {
    		Vector<Integer> secondHexes = (Vector<Integer>) SOCBoard.getAdjacentHexesToNode(secondSettlement);
    	}*/
    	
    }
    
    /** Prints out list of resources for debugging purposes */
    private void printResources(SOCResourceSet set){
    	client.sendText(game, ourPlayerData.getName()+" "+set.toFriendlyString());
    }
    

    
    /** Added by Katie
     * 
     * @return expected number of each type of resource per roll
     */
    protected double[] expectedNumResources(){
    	double[] resources= new double[6];
    	Vector settlements= ourPlayerData.getSettlements();
    	for (int i=0; i<=settlements.size(); i++){
    		int coord= ((SOCSettlement) settlements.get(i)).getCoordinates();
    		int type= game.getBoard().getHexTypeFromCoord(coord);
    		int number= game.getBoard().getNumberOnHexFromNumber(coord);
    		resources[type-1]+= PROB[number];
    	}
    	Vector cities= ourPlayerData.getCities();
    	for (int i=0; i< cities.size(); i++){
    		int coord= ((SOCCity) cities.get(i)).getCoordinates();
    		int type= game.getBoard().getHexTypeFromCoord(coord);
    		int number= game.getBoard().getNumberOnHexFromNumber(coord);
    		resources[type-1]+= 2*PROB[number];
    	}
    	return resources;
    }
    
    // Added by Ryan
    // Modified by Katie: returns true if player can ... Does not request the trade
    // Returns true if we can trade with the bank to get the resources in needSet, and asks client to do so
    // Returns false otherwise
    protected SOCTradeOffer tradeWithBank (SOCResourceSet costSet, SOCGame ga, int player) {
    	//this.client.sendText(this.game, " trading?");
    	SOCPlayer PlayerData= ga.getPlayers()[player];
    	if(PlayerData.getResources().contains(costSet))
    		// We already have the resources, don't need to wait
    		return null;

    	//this.client.sendText(this.game, " trading.");
    	
    	// excess contains exactly the resources that we have but don't need to pay costSet
    	SOCResourceSet excess = PlayerData.getResources().copy();
    	excess.subtract(costSet);
    	
    	// needed contains exactly the resources that we need to get to pay costSet
    	SOCResourceSet needed = costSet.copy();
    	needed.subtract(PlayerData.getResources());
    	
    	SOCResourceSet givenSet = new SOCResourceSet();
    	
    	// we need to trade this many times to be successful
    	int numTradesNeeded = needed.getTotal();
    	
    	// Note: ports = [has3to1, hasClay, hasOre, hasSheep, hasWheat, hasWood]
    	// These match up with SOCResourceConstants
    	boolean[] ports = PlayerData.getPortFlags();
    	
    	// Go through excess in order, trying to trade
    	for(int res=1; res<ports.length; res++) {
    		int quantity = excess.getAmount(res);
    		if(ports[res]) {
    			int numTrades = quantity / 2;
    			numTrades = Math.min(numTrades, numTradesNeeded);
    			excess.subtract(2*numTrades, res);
    			givenSet.add(2*numTrades, res);
    			numTradesNeeded -= numTrades;
    		}
    		else if(ports[0]) {
    			int numTrades = quantity / 3;
    			numTrades = Math.min(numTrades, numTradesNeeded);
    			excess.subtract(3*numTrades, res);
    			givenSet.add(3*numTrades, res);
    			numTradesNeeded -= numTrades;
    		}
    		else {
    			int numTrades = quantity / 4;
    			numTrades = Math.min(numTrades, numTradesNeeded);
    			excess.subtract(4*numTrades, res);
    			givenSet.add(4*numTrades, res);
    			numTradesNeeded -= numTrades;
    		}
    	}
    	
    	if(numTradesNeeded > 0) {
    		//this.client.sendText(this.game, " no trade to be made.");
    		// We can't trade for the necessary resources
        	return null;
    	}
    	//this.client.sendText(this.game, " sending offer: "+givenSet.toFriendlyString()+" for "+needed.toFriendlyString());
    	// Success! Put in the call to the client.
    	this.client.sendText(this.game, " needs {"+costSet.toFriendlyString()+"}");
    	this.client.sendText(this.game, " has {"+PlayerData.getResources().toFriendlyString()+"}");
    	this.client.sendText(this.game, " trades {"+givenSet.toFriendlyString()+"} for {"+needed.toFriendlyString()+"}" );

    	//TODO: Katie moved this to buildOrGetResourceByTrade...
    	
    	//client.bankTrade(game, givenSet, needed);
		//waitingForTradeMsg = true;
        //pause(500);
    	this.client.sendText(this.game, " has {"+PlayerData.getResources().toFriendlyString()+"} after trading");
       // this.client.sendText(this.game, " done trading.");
    	// ignore everything except givenSet and needed...
        return new SOCTradeOffer("", -1, new boolean[4], givenSet, needed);
    }
    
    
    protected void tradeWithBank(){
    	Vector settlements= ourPlayerData.getSettlements();
    	Vector cities= ourPlayerData.getCities();
    	boolean havePort= false;
    	for(int i=0; i<settlements.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i=0; i<cities.size(); i++){
    		int coord= ((SOCPlayingPiece) settlements.get(i)).getCoordinates();
    		if(game.getBoard().getPortTypeFromNodeCoord(coord)==SOCBoard.MISC_PORT)
    			havePort=true; 	
    	}
    	
    	for(int i= 0; i<=SOCResourceConstants.WOOD; i++){
    		int numRes= ourPlayerData.getResources().getAmount(i);
    		SOCResourceSet give= new SOCResourceSet();
    		SOCResourceSet get= new SOCResourceSet();
    		get.add(1,(i+1)%SOCResourceConstants.WOOD);
    		if(numRes>=3 && havePort){
    			give.add(3,i);
    			client.bankTrade(game,give,get);   			
    		} else if(numRes>=4){
    			give.add(4,i);
    			client.bankTrade(game,give, get);
    		}
    		
    	}
    	
    }
    
    
    /** Added by Katie 
     * A Move is a list of actions to perform in a turn, including
     * optionally a devCard to play, a series of bankTrades to make
     * and a series of pieces (including devCards to buy)*/
    
    private class Move implements Cloneable{
    	private Vector<SOCTradeOffer> trades; // trades to make with the bank
    	private Vector<SOCPlayingPiece> pieces; // pieces to buy
    	private int buyDevCards; // the number of devCards to buy
    	private int devCard; // type of devCard to play, -1 if no devCard to play
    	
    	public Move(){
    		trades= new Vector<SOCTradeOffer>();
    		pieces= new Vector<SOCPlayingPiece>();
    		buyDevCards= 0;
    		devCard= -1; 
    	}
    	
    	public void addTrade(SOCTradeOffer t){
    		trades.add(t);
    	}
    	
    	public void addPiece(SOCPlayingPiece p){
    		pieces.add(p);
    	}
    	
    	public void setDevCards(int i){
    		buyDevCards=i;
    	}
    	
    	public Vector<SOCTradeOffer> getTrades(){
    		return trades;
    	}
    	
    	public Vector<SOCPlayingPiece> getPieces(){
    		return pieces;
    	}
    	public int devCardsToBuy(){
    		return buyDevCards;
    	}
    	public int devCardToPlay(){
    		return devCard;
    	}
    	
    	public Move clone(){
    		Move move= new Move();
    		move.trades= (Vector<SOCTradeOffer>) this.trades.clone();
    		move.pieces= (Vector<SOCPlayingPiece>) this.pieces.clone();
    		move.buyDevCards= this.buyDevCards;
    		move.devCard= this.devCard;
    		return move;
    	}
    }
    
    // SOCGame.ROAD_SET
    
    private int numTrue(boolean[] a){
    	int sum=0;
    	for(int i=0; i<a.length; i++){
    		if (a[i]) sum++;
    	}
    	return sum;
    }
    
    
    private class Node{
    	private int[] buildingCombo;
    	private SOCTradeOffer trade;
    	private Vector<Node> children;
    	
    	public Node(int[] build, SOCTradeOffer trade){
    		buildingCombo= build;
    		this.trade= trade;
    		children= new Vector<Node>();
    	}
    	
    	public void addChild(Node n){
    		children.add(n);
    	}
    	public int[] getBuildSet(){
    		return buildingCombo;
    	}
    }
    
    /** returns the total number of resources needed to build this plan */
    private SOCResourceSet sumOfPlan(int[] plan){
    	SOCResourceSet roads= SOCGame.ROAD_SET.copy();
		roads.times(plan[0]);
		SOCResourceSet settlements= SOCGame.SETTLEMENT_SET.copy();
    	settlements.times(plan[1]);
		SOCResourceSet cities= SOCGame.CITY_SET.copy();
	    cities.times(plan[2]);
	    SOCResourceSet cards= SOCGame.CARD_SET.copy();
		cards.times(plan[3]);
		cards.add(roads);
		cards.add(settlements);
		cards.add(cities);
		return cards;
    }
    
    //TODO: Katie: no duplicates in the tree
    // take care of more than one road, city, etc.
    // 
    
    
    /** Added by Katie: builds a tree */
    private void buildTree(Node node, SOCGame game, int player){
    	int[] build= node.getBuildSet();
    	SOCResourceSet resources= game.getPlayers()[player].getResources();
    	for(int i=0; i<build.length; i++){
    		build[i]++;
    		SOCResourceSet wanted= sumOfPlan(build);
    		if(SOCResourceSet.gte(resources, wanted)){
    			Node child= new Node((int[])build.clone(), null);
    			buildTree(child, game, player);
    			node.addChild(child);
    		} else {
	    		SOCTradeOffer trade=tradeWithBank(wanted, game, player);
	    		if(trade!=null){
	    			Node child= new Node((int[])build.clone(),trade);
	    			buildTree(child,game, player);
	    			node.addChild(child);
	    		}
    		}
    		build[i]--;
    	}
    }
    
    /** Add all possible moves with this combination of things to build*/
    private void addMoves(Vector<Move> moves, Node node, SOCGame game, int player){
    	SOCPlayer PlayerData= game.getPlayer(player);
    	boolean[] potentialSettlements= PlayerData.getPotentialSettlements();
    	boolean[] potentialRoads= PlayerData.getPotentialRoads();
    	boolean[] potentialCities= PlayerData.getPotentialCities();
    	int numSet= numTrue(potentialSettlements);
    	int numRoad= numTrue(potentialRoads);
    	int numCit= numTrue(potentialCities);
    	
    	int[] Roads= new int[numRoad];
    	int[] Sets= new int[numSet];
    	int[] Cities= new int[numCit];
    
    	int ind=0;
    	for(int i=0; i<potentialRoads.length; i++){
    		if (potentialRoads[i]) Roads[ind++]=i;
    	}
    	ind=0;
    	for(int i=0; i<potentialSettlements.length; i++){
    		if (potentialSettlements[i]) Sets[ind++]=i;
    	}
    	ind=0;
    	for(int i=0; i<potentialCities.length; i++){
    		if (potentialCities[i]) Cities[ind++]=i;
    	}
    	
    	int [] combo= node.getBuildSet();
    	
    	int poss= choose(numRoad,combo[0])*choose(numSet,combo[1])
		*choose(numCit,combo[2])*combo[3];
    	
    	int roadChoices= choose(numRoad,combo[0]);
    	int setChoices= choose(numSet,combo[1]);
    	int cityChoices= choose(numCit,combo[2]);
    	
    	
    	/* 4C2-- r= 3
    	if level==2
    	if r<=numRoad-1, first = 1
    	second = r + 1
    	
    	if r<=numRoad-1+numRoad-2, eg. r=5
    	first =2
    	second = r-1 //or second= r-numRoad+3
    	
    	else e.g r=6
    	first = 3
    	second = 4 
    	
    	5C2-- 
    	if r<numRoad-1
    	first=1;
    	second= r+1;
    	
    	if r< numRoad-1+numRoad-2 r= 7 should have first = 1, second= 4 
    	first= 2;
    	second= r-2; //or second= r-numRoad+3
    	
    	if r<= numRoad-1+numRoad-2+numRoad-3 = i* numRoad - (i*(i-1)/2) // eg 8, 9
    	first= 3;
    	second = r-4; r-2*numRoad+6    
    	
    	else eg 10
    	first= 4;
    	second= 5; // r-3*numRoad+10
    	

		For numRoad C 2
		int first=0;
    	int second= road+1;
    	i= 1;
    	while(road>= i*numRoad-(i*(i-1)/2)-1){
    		first= i;
    		second= road- numRoad+ ((i+1)*i)/2)+1;
    		i++;
    	}
    		
    		 
    	}
    	for(int i=1; i<numRoad; i++){
    		if(r>i*numRoad-(i*(i-1)/2)){
    		}
    	}
    	
    	6C2
    	
    	3rd row: eg. 10
    	first= 3
    	second= r- 2* numRoad+6;
    	
    	4th row: eg 13,14
    	first= 4;
    	second= r- 3*numRoad+10;
    	
    	5th row: eg 15
    	first= 5;
    	second= r- 4*numRoad+15;
    	
    	
    	15
    	
    	12 13 14 15 16
    	23 24 25 26
    	34 35 36
    	45 46
    	56
    	
    	
    	
    	
    	1 3 6 10 
    	
    	1 4 10 20 
    	
    	4 c 3
    	
    	123 124 134
    	234
    	
    	5 c 3
    	123 124 125 134 135 145 6
    	234 235  245 8
    	345 10
    	
    	6 c 3
    	123 124 125 126 134 135 136 145 146 156 10
    	234 235 236 245 246 256 16
    	345 346 356 19
    	456 20
    	
    	if r<numRoad
    	first=1;
    	second= 
    	
    	
    	*/
    	
    	
    	
    	for(int i=0; i<poss; i++){
    		Move move= new Move();
    		int road= i/setChoices/cityChoices;
    		int set= (i/cityChoices)%setChoices;
    		int city= i%cityChoices;
    		
    		if(numRoad!=0){
    			SOCRoad r= new SOCRoad(PlayerData,Roads[road],game.getBoard());
    			move.addPiece(r);
    		}
    		if(numSet!=0){
    			SOCSettlement s= new SOCSettlement(PlayerData,Roads[road],game.getBoard());
    			move.addPiece(s);
    		}
    		if(numCit!=0){
    			SOCCity c= new SOCCity(PlayerData,Roads[road],game.getBoard());
    			move.addPiece(c);
    		}
    		move.setDevCards(combo[3]);
    		//int level= numRoad;
    		//while(level>0){
    			
    		//}
    		
        	int first=0;
        	int second= road+1;
        	i= 1;
        	while(road>= i*numRoad-(i*(i-1)/2)-1){
        		first= i;
        		second= road- numRoad+((i+1)*i/2)+1;
        		i++;
        	}
    		// add the move to the set
    		moves.add(move);
    	}
		for (Node child:node.children) {
			addMoves(moves,child,game,player);
		}
    }
    
    protected Vector<Move> possibleMoves(SOCGame game, int player){
    	Node root= new Node(new int[5], null);
    	buildTree(root, game, player);
    	Vector<Move> moves= new Vector<Move>();
    	// Add the moves for all nodes in the tree
    	addMoves(moves, root,game,player);
    	return moves;    	
    }
    
    /** Added by Katie- returns a Vector of all possible moves in a given turn
     * a move consists of a set of trades, a set of SOCpieces to build, and a
     * devCard to play
     * @return 
     */
  
    //TODO: Note*** Always trade first, then build cities, then the rest

  /*  protected Vector<Move> possibleMoves(SOCGame game, int player){
    	SOCPlayer PlayerData= game.getPlayer(player);
    	Vector<Move> moves= new Vector<Move>();
    	
    	SOCResourceSet resources= PlayerData.getResources().copy();
    	
    	boolean[] potentialSettlements= PlayerData.getPotentialSettlements();
    	boolean[] potentialRoads= PlayerData.getPotentialRoads();
    	boolean[] potentialCities= PlayerData.getPotentialCities();
    	int numSet= numTrue(potentialSettlements);
    	int numRoad= numTrue(potentialRoads);
    	int numCit= numTrue(potentialCities);
    	
    	int remainingSettlements= PlayerData.getNumPieces(SOCPlayingPiece.SETTLEMENT);
    	
    	/*
    	int maxRoads=0;
    	while(SOCResourceSet.gte(resources,SOCGame.ROAD_SET)){
    		resources.subtract(SOCGame.ROAD_SET);
    		maxRoads++;
    	}
    	// min of roads available and resource limitations
    	maxRoads= Math.min(maxRoads,PlayerData.getNumPieces(SOCPlayingPiece.ROAD));
    	
    	// reset resources to initial values
    	resources= PlayerData.getResources().copy();
    	int maxSettlements=0;
    	while(SOCResourceSet.gte(resources,SOCGame.SETTLEMENT_SET)){
    		resources.subtract(SOCGame.SETTLEMENT_SET);
    		maxSettlements++;
    	} // can build a city in which case we have a settlement free
    	//maxSettlements= Math.min(maxSettlements, PlayerData.getNumPieces(SOCPlayingPiece.SETTLEMENT));
    	resources= PlayerData.getResources().copy();
    	int maxCities=0;
    	while(SOCResourceSet.gte(resources,SOCGame.CITY_SET)){
    		resources.subtract(SOCGame.CITY_SET);
    		maxCities++;
    	}
    	maxCities= Math.min(maxCities,PlayerData.getNumPieces(SOCPlayingPiece.CITY));
    	
    	resources= PlayerData.getResources().copy();
    	int maxDevCards=0;
    	while(SOCResourceSet.gte(resources,SOCGame.CARD_SET)){
    		resources.subtract(SOCGame.CARD_SET);
    		maxDevCards++;
    	}    
    	maxDevCards= Math.min(maxDevCards,game.getNumDevCards());
    	
    	// building combos contains an array for each possible combination of number
    	// of each type of thing to be built
    	// e.g. [0 1 0 0] [1 1 0 0] [2 0 0 0] [1 0 0 0] [0 0 0 0] means:
    	// nothing built, or 1 road, or 2 roads, or 1 road 1 settlement, or 1 settlement 
    	Vector<int[]> buildingCombos= new Vector<int[]>();
    	
    	    	
    	resources= PlayerData.getResources().copy();
    	for(int r=0; r<maxRoads; r++){
    		SOCResourceSet roads= SOCGame.ROAD_SET.copy();
    		roads.times(r);
    		for(int s=0; s<maxSettlements; s++){
    			SOCResourceSet settlements= SOCGame.SETTLEMENT_SET.copy();
        		settlements.times(s);
    			for(int c=0; c<maxCities; c++){
    				SOCResourceSet cities= SOCGame.CITY_SET.copy();
    	    		cities.times(c);
    				for(int d=0; d<maxDevCards; d++){
    					SOCResourceSet dCards= SOCGame.CARD_SET.copy();
    		    		roads.times(d);
    		    		
    		    		dCards.add(roads);
    		    		dCards.add(settlements);
    		    		dCards.add(cities);
    		    		
    		    		// we get a settlement back to use when we build a city
    		    		if(SOCResourceSet.gte(resources,dCards) && s-c<=remainingSettlements){
    		    			int [] combo= new int[] {r, s, c, d};
    		    			buildingCombos.add(combo);
    		    		}
    					
    				}
    			}
    		}
    	}
    	*/
    	
    	// [road set cit dev]
    	// all possible Moves based just on roads
    	/*Vector<Vector<Integer>> roadCombos= new Vector<Vector<Integer>>();
    	
    	for(int i=0; i<buildingCombos.size(); i++){
    		int[] combo= buildingCombos.get(i);
    		int roadsLeft= combo[0];
    		int roadsBuilt= 0;
    	//	int potRoads= numTrue(potentialRoads);
    		for(int j=0; j<potentialRoads.length; j++){
    			if(potentialRoads[j]){
	    			Vector<Integer> roadList= new Vector<Integer>();
	    			roadList.add(j);
	    			roadCombos.add(roadList);
	    			break;
    			}
    		}
    		roadsBuilt++;
    		roadsLeft--;
    		while(roadsLeft>0){
    			for(int j=0; j<roadCombos.size(); j++){
    				Vector<Integer> roadList= roadCombos.get(j);
    				if(roadList.size()==roadsBuilt-1){
    					// clone the game and add the road, then add all potential roads
    					for(int k=0; k<roadList.size(); k++){
    						SOCRoad r= new SOCRoad(PlayerData,k,game.getBoard());
    					}
    				}
    			}
    		}
    	}*/
    	
    /*	for(int i=0; i<buildingCombos.size(); i++){
    		int[] combo= buildingCombos.get(i);
    		int poss= choose(numRoad,combo[0])*choose(numSet,combo[1])
    					*choose(numCit,combo[2])*combo[3];
    		for(int r=0; r<choose(numRoad,combo[0]); r++){
    			
    			if(combo[0]>1){
    				
    			} else if(combo[0]==1){
    				
    			} else{
    				
    			}
    			
    		}
    		
    	}
    	
    	boolean[] portFlags= PlayerData.getPortFlags();
    	
        boolean[] to= new boolean[game.maxPlayers];
    	for (int i = 0; i < game.maxPlayers; i++)
        {
            to[i] = false;
        }

//        SOCTradeOffer bankTrade = new SOCTradeOffer(game.getName(), PlayerData.getPlayerNumber(), to, give, get);

       return moves;    	
    	
    }
    */
    private int fact(int x){
    	if (x<=1) return 1;
    	else return x*fact(x-1);
    }
    
    /** return xCy */
    private int choose(int x, int y){
    	return fact(x)/(fact(x)*fact(x-y));
    }
    
    
    /** will hold weight information for evaluation function */
    float [] weights;
    
    /** Added by Katie
     * returns a float estimated value of the current board state
     * for game ga for player player
     * 
     * number of settlements
		number of cities
		number of each type of resource
		have a 3:1 port?
		number of each type of unplayed dev card
		Expected number of each type of resource per turn
		Expected number of each type of resource per turn for each 2:1 port owned
		have largest army?
		size of largest army- size of our army +1
		have longest road?
		length of longest road- length of our longest road +1
		number spots available to build settlements
		number spots available to build roads?
		
     * 
     */
    
    protected double evaluateBoard(SOCGame ga, int player){
    	SOCPlayer playerData= ga.getPlayers()[player];
    	int numSettlements= playerData.getSettlements().size();
    	int numCities= playerData.getCities().size();
    	int haveMiscPort= (playerData.getPortFlag(SOCBoard.MISC_PORT)? 1:0);
    	int[] devCards= playerData.getDevCards().getTotalTypes();
    	double[] expectedResources= playerData.expectedNumResources();
    	boolean[] portFlags= playerData.getPortFlags();
    	int hasArmy= playerData.hasLargestArmy()?1:0;
    	int knightDifference= ga.getPlayerWithLargestArmy().getNumKnights()-playerData.getNumKnights();
    	int hasRoad= playerData.hasLongestRoad()?1:0;
    	int roadDif= ga.getPlayerWithLongestRoad().getLongestRoadLength()-playerData.getLongestRoadLength();
    	int potentialSettlements= playerData.numPotentialSettlements();
    	int potentialRoads= playerData.numPotentialRoads();
    	
    	/*SOCPlayer[] players= ga.getPlayers();
    	SOCPlayer opp= players[0];
    	for(int i=1; i<players.length; i++){
    		if (players[i].getPlayerNumber()!=playerData.getPlayerNumber()){
    			opp= players[i];
    		}
    	}*/
    	
    	double rank= 0.0;
    	rank+=numSettlements*weights[0];
    	rank+=numCities*weights[1];
    	rank+=haveMiscPort*weights[2];
    	for(int i=0; i<=SOCDevCardConstants.MAX_KNOWN; i++){
    		rank+= devCards[i]*weights[i+3];
    	}
    	
    	for(int i=0; i<SOCResourceConstants.WOOD; i++){
    		rank+= expectedResources[i]*weights[i+12];
    	}
    	
    	for(int i=0; i<portFlags.length-1; i++){
    		rank+= (portFlags[i]? weights[i+17]:0);
    	}
    	rank+= hasArmy*weights[22];
    	rank+= knightDifference*weights[23];
    	rank+= hasRoad*weights[24];
    	rank+= roadDif*weights[25];
    	rank+= potentialSettlements*weights[26];
    	rank+= potentialRoads*weights[27];
    	
    	/*
    	int theirSettlements= opp.getSettlements().size();
    	int theirCities= opp.getCities().size();
    	int theirMiscPort= (opp.getPortFlag(SOCBoard.MISC_PORT)? 1:0);
    	int theirDevCards= opp.getDevCards().getTotal(); // don't know the type
    	double[] theirExpectedResources= opp.expectedNumResources();
    	boolean[] theirPortFlags= opp.getPortFlags();
    	int theirArmy= opp.hasLargestArmy()?1:0;
    	int theirKnightDifference= game.getPlayerWithLargestArmy().getNumKnights()-opp.getNumKnights();
    	int theirHasRoad= opp.hasLongestRoad()?1:0;
    	int theirRoadDif= game.getPlayerWithLongestRoad().getLongestRoadLength()-opp.getLongestRoadLength();
    	int theirPotentialSettlements= opp.numPotentialSettlements();
    	int theirPotentialRoads= opp.numPotentialRoads();
    	*/
    	return rank;

    }

    
    
    /** Holds a current game state used with cloned boards for max 4 search algorithm (Nick)
     * 
     */
    private class GameState {
    	private SOCGame game;
    	private int cutoff;
    	private int player;
    	
    	/** Creates a new game state with given cloned board, current player number, and current cutoff
    	 * 
    	 * @param g cloned game board
    	 * @param p player number of turn player
    	 * @param c current cutoff counter
    	 */
    	public GameState (SOCGame g, int p, int c) {
    		game = g;
    		cutoff = c;
    		player = p;
    	}
    }	
    
    
    /** Performs the moves on a given game board for player number pid
     * @param game
     * @param moves
     * @param pid
     */
    public static void performMoves(SOCGame game, Move moves, int pid) {
    	//Need to perform the moves on a cloned board (somehow bypass client)
   	
    	SOCPlayer player= game.getPlayers()[pid];
    	SOCResourceSet playerResources= player.getResources();
    	Vector<SOCTradeOffer> trades= moves.getTrades();
    	Vector<SOCPlayingPiece> pieces= moves.getPieces();
    	int devCards= moves.devCardsToBuy();
    	int playCard= moves.devCardToPlay();
    	
    	// Make all trades- assumes they are legal.
    	for(int i=0; i<trades.size(); i++){
    		SOCTradeOffer trade= trades.get(i);
    		playerResources.subtract(trade.getGiveSet());
    	    playerResources.add(trade.getGetSet());
    	}
    	
    	for(int i=0; i<pieces.size(); i++){
    		game.putPiece(pieces.get(i));
    	}
    	
    	for(int i=0; i<devCards; i++){
    		game.buyDevCard2(pid);
    	}
    	
    	
    }
    
    private float evalBoard(SOCGame game) {
    	//place-holder for Katie's evaluation function
    	return 0f;
    }
    
    /** Max4 Algorithm that searches through turns to find best available move for the current turn (Nick)
     * 
     * @param game Current game being played
     * @param player ID number of current player (player who wants to find best move)
     * @param maxDepth How deep the search algorithm searches
     * @return Best possible set of moves for current board
     */
    
    private Move max4Search (SOCGame game,int player,int maxDepth) {
    	Vector<Move> poss = possibleMoves(game,player);
    	double [] vals = new double[poss.size()];
    	double max= Double.MIN_VALUE;
    	int maxIndex= 0;
    	double [] scores= new double[game.maxPlayers];
    	for (int i=0;i<poss.size();i++) {
    		SOCGame clone = game.resetAsCopy();
    		performMoves(clone,poss.get(i),player);
        	GameState current = new GameState(clone,player,0);
    		scores= maxValue2(current,maxDepth, player);
    		if(scores[player]>max){
    			max= scores[player];
    			maxIndex= i;
    		}
    	}
		return poss.get(maxIndex);
    }
    
    
    /** Returns the max value for a given game state for player number player
     *  with a certain depth cutoff (Nick)
     * 
     * @param gs Current GameState
     * @param maxDepth Cutoff for search algorithm
     * @return float value of a given move vector
     */
    
 /*   public double maxValue(GameState gs, int maxDepth, int pl) {
    	if (gs.cutoff == maxDepth) {
    		return evaluateBoard(gs.game, pl);
    	} 
    	else {
    		SOCPlayer player = game.getPlayer(gs.player);
    		gs.game.checkForWinner();
        	SOCPlayer winner = gs.game.getPlayerWithWin();
    		if (winner == player) {
    			return Double.MAX_VALUE;
    		} 
    		else {
    			for (int i=1; i<poss.size(); i++){
    				SOCGame clone = gs.game.resetAsCopy();
    	    		performMoves(clone,poss.get(i));
    	    		int next = gs.player; //somehow get next player
    	        	GameState current = new GameState(clone,next,gs.cutoff+1);
    	        	return maxValue(current,maxDepth);
    			}
    		}
    	}
    }
    */

    /** Returns the max value for a given game state for player number player
     *  with a certain depth cutoff (Nick)
     * 
     * @param gs Current GameState
     * @param maxDepth Cutoff for search algorithm
     * @return float value of a given move vector
     */

    public double[] maxValue2(GameState gs, int maxDepth, int pl) {
		SOCPlayer player = game.getPlayer(gs.player);
		// check if game is over
		int winner= gs.game.winningPlayer();
       	double [] scores= new double[gs.game.maxPlayers];
    	if(winner!=-1){	
    		scores[winner]= Double.MAX_VALUE;
    		return scores;
        }
		else {
			if (gs.cutoff == maxDepth) {
				for(int i=0; i<gs.game.maxPlayers; i++){
					scores[i]= evaluateBoard(gs.game, i);
				}
	    		return scores;
	    	} 
			int nextPlayer= nextPlayer(pl, gs.game);
			Vector<Move> poss = possibleMoves(game,nextPlayer);
			int maxIndex= -1;
			double[] results= new double[gs.game.maxPlayers];
			double max= Double.MIN_VALUE;
	    	for (int i=0;i<poss.size();i++) {
	    		SOCGame clone = game.resetAsCopy();
	    		performMoves(clone,poss.get(i),nextPlayer);
	        	GameState current = new GameState(clone,nextPlayer,gs.cutoff+1);
	    		results= maxValue2(current,maxDepth, nextPlayer);
	    		if(results[nextPlayer]>max){
	    			max= scores[nextPlayer];
	    			scores= results;
	    		} 
	    		// in case of ties
	    		if(results[nextPlayer]==max && Math.random()>0.4){
	    			scores= results;
	    		}
			}
	    	return scores;
    	}
    } 
    
    
    /** Returns the max value for a given game state for player number player
     *  with a certain depth cutoff (Nick) Takes random dice rolls into account
     * 
     * @param gs Current GameState
     * @param maxDepth Cutoff for search algorithm
     * @return float value of a given move vector
     */

    public double[] maxValue3(GameState gs, int maxDepth, int pl) {
		SOCPlayer player = game.getPlayer(gs.player);
		gs.game.checkForWinner();
		// check if game is over
		boolean gameOver= true;
       	SOCPlayer winner = gs.game.getPlayerWithWin();
       	double [] scores= new double[gs.game.maxPlayers];
    	if(gameOver){	
    		int win= winner.getPlayerNumber();
    		scores[win]= Double.MAX_VALUE;
    		return scores;
        }
		else {
			if (gs.cutoff == maxDepth) {
				for(int i=0; i<gs.game.maxPlayers; i++){
					scores[i]= evaluateBoard(gs.game, i);
				}
	    		return scores;
	    	} 
			int nextPlayer= nextPlayer(pl, gs.game);
			Vector<Move> poss = possibleMoves(game,nextPlayer);
			int maxIndex= -1;
			double[] results= new double[gs.game.maxPlayers];
			double max= Double.MIN_VALUE;
	    	for (int i=0;i<poss.size();i++) {
	    		SOCGame clone = game.resetAsCopy();
	    		performMoves(clone,poss.get(i),nextPlayer);
	        	GameState current = new GameState(clone,nextPlayer,gs.cutoff+1);
	    		results= maxValue2(current,maxDepth, nextPlayer);
	    		if(results[nextPlayer]>max){
	    			max= scores[nextPlayer];
	    			scores= results;
	    		}
			}
	    	return scores;
    	}
    } 

    public int nextPlayer(int player, SOCGame game){
    	SOCPlayer[] players= game.getPlayers();
    	int i= player+1;
    	while (i< game.maxPlayers && players[i]==null){
    		i++;
    	}
    	if(i!=game.maxPlayers) return i;
    	i=0;
    	while( i<player && players[i]==null){
    		i++;
    	}
    	return i;
    }
    
}

